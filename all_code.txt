--- File: ./run_bot.py ---
#!/usr/bin/env python3
"""
èƒ½é‡ç§Ÿèµæœºå™¨äººå¯åŠ¨è„šæœ¬

ä½¿ç”¨æ–¹æ³•:
    python run_bot.py              # å¯åŠ¨æœºå™¨äºº
    python run_bot.py --test       # æµ‹è¯•æ¨¡å¼
    python run_bot.py --help       # æ˜¾ç¤ºå¸®åŠ©

ç¯å¢ƒå˜é‡:
    TELEGRAM_BOT_TOKEN     - Telegram Bot Token (å¿…éœ€)
    DB_HOST               - æ•°æ®åº“ä¸»æœº
    DB_NAME               - æ•°æ®åº“å
    DB_USER               - æ•°æ®åº“ç”¨æˆ·
    DB_PASSWORD           - æ•°æ®åº“å¯†ç 
    TELEGRAM_ADMIN_UID    - ç®¡ç†å‘˜ç”¨æˆ·ID (å¯é€‰)
"""
"""
èƒ½é‡ç§Ÿèµæœºå™¨äººå¯åŠ¨è„šæœ¬
"""

import sys
import os
import asyncio
import signal
import logging
import argparse
from pathlib import Path
from dotenv import load_dotenv

# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°Pythonè·¯å¾„
PROJECT_DIR = Path(__file__).parent
BOT_DIR = PROJECT_DIR / "energy_rental_bot"
sys.path.insert(0, str(PROJECT_DIR))

from energy_rental_bot.bot.energy_bot import EnergyRentalBot
from energy_rental_bot.utils.energy_utils import EnergyUtils


def main(test_mode=False):
    """ä¸»å‡½æ•°"""
    # è®¾ç½®æ—¥å¿—
    EnergyUtils.setup_logging()

    # å¼ºåˆ¶è®¾ç½®æ—¥å¿—çº§åˆ«ï¼Œç¡®ä¿èƒ½çœ‹åˆ°é”™è¯¯
    logging.getLogger('httpx').setLevel(logging.WARNING)
    logging.getLogger('telegram').setLevel(logging.INFO)

    logger = logging.getLogger(__name__)

    if test_mode:
        logger.info("å¯åŠ¨èƒ½é‡ç§Ÿèµæœºå™¨äºº (æµ‹è¯•æ¨¡å¼)...")
    else:
        logger.info("å¯åŠ¨èƒ½é‡ç§Ÿèµæœºå™¨äºº...")

    # åˆ›å»ºæœºå™¨äººå®ä¾‹
    bot = EnergyRentalBot()

    try:
        if test_mode:
            # åˆå§‹åŒ–æœºå™¨äººè¿›è¡Œæµ‹è¯•
            asyncio.run(bot.initialize())
            logger.info("æµ‹è¯•æ¨¡å¼ï¼šæœºå™¨äººåˆå§‹åŒ–æˆåŠŸ")
            return

        # ä¿®å¤ï¼šç§»é™¤æ‰‹åŠ¨ä¿¡å·å¤„ç†
        # application.run_polling() ä¼šè‡ªåŠ¨å¤„ç† SIGINT å’Œ SIGTERM

        # ç›´æ¥å¯åŠ¨æœºå™¨äºº
        logger.info("æœºå™¨äººæ­£åœ¨è¿è¡Œï¼ŒæŒ‰ Ctrl+C åœæ­¢...")
        bot.start()

    except KeyboardInterrupt:
        # è¿™é‡Œé€šå¸¸ä¸ä¼šè§¦å‘ï¼Œå› ä¸º run_polling æ•è·äº†å®ƒï¼Œä½†ä¿ç•™ä½œä¸ºå®‰å…¨æªæ–½
        logger.info("æ”¶åˆ°é”®ç›˜ä¸­æ–­ï¼Œæ­£åœ¨åœæ­¢...")
    except Exception as e:
        logger.error(f"æœºå™¨äººè¿è¡Œå‡ºé”™: {str(e)}")
        raise
    finally:
        logger.info("æœºå™¨äººå·²åœæ­¢")


def check_environment():
    """æ£€æŸ¥ç¯å¢ƒé…ç½®"""
    # åŠ è½½.envæ–‡ä»¶
    load_dotenv()
    # æ£€æŸ¥å¿…è¦çš„ç¯å¢ƒå˜é‡
    required_vars = [
        'TELEGRAM_BOT_TOKEN',
        'DB_HOST',
        'DB_NAME',
        'DB_USER',
        'DB_PASSWORD'
    ]

    missing_vars = []
    for var in required_vars:
        if not os.getenv(var):
            missing_vars.append(var)

    if missing_vars:
        print("âŒ ç¼ºå°‘å¿…è¦çš„ç¯å¢ƒå˜é‡:")
        for var in missing_vars:
            print(f"   - {var}")
        print("\nè¯·æ£€æŸ¥ .env æ–‡ä»¶æˆ–ç¯å¢ƒå˜é‡è®¾ç½®")
        print("å‚è€ƒ .env.example æ–‡ä»¶")
        sys.exit(1)

    print("âœ… ç¯å¢ƒé…ç½®æ£€æŸ¥é€šè¿‡")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='èƒ½é‡ç§Ÿèµæœºå™¨äºº')
    parser.add_argument('--test', action='store_true', help='æµ‹è¯•æ¨¡å¼ï¼Œåªæ£€æŸ¥é…ç½®ä¸å¯åŠ¨æœºå™¨äºº')
    parser.add_argument('--verbose', '-v', action='store_true', help='è¯¦ç»†è¾“å‡º')

    args = parser.parse_args()

    print("ğŸ”‹ èƒ½é‡ç§Ÿèµæœºå™¨äºº")
    print("=" * 30)

    if args.verbose:
        print(f"Pythonç‰ˆæœ¬: {sys.version}")
        print(f"å·¥ä½œç›®å½•: {os.getcwd()}")

    # æ£€æŸ¥ç¯å¢ƒ
    check_environment()

    if args.test:
        print("ğŸ§ª è¿è¡Œæµ‹è¯•æ¨¡å¼...")
        try:
            main(test_mode=True)
            print("âœ… æµ‹è¯•é€šè¿‡ï¼æœºå™¨äººé…ç½®æ­£ç¡®")
        except Exception as e:
            print(f"âŒ æµ‹è¯•å¤±è´¥: {str(e)}")
            sys.exit(1)
        sys.exit(0)

    # è¿è¡Œæœºå™¨äºº
    try:
        main()
    except KeyboardInterrupt:
        print("\nğŸ‘‹ æœºå™¨äººå·²åœæ­¢")
    except Exception as e:
        print(f"\nâŒ å¯åŠ¨å¤±è´¥: {str(e)}")
        sys.exit(1)
-e 

--- File: ./quick_start.py ---
#!/usr/bin/env python3
"""
èƒ½é‡ç§Ÿèµæœºå™¨äººå¿«é€Ÿå¼€å§‹æ¼”ç¤ºè„šæœ¬
"""

import os
import sys
import subprocess
from pathlib import Path

def main():
    """ä¸»å‡½æ•°"""
    print("ğŸš€ èƒ½é‡ç§Ÿèµæœºå™¨äºº - å¿«é€Ÿå¼€å§‹")
    print("=" * 40)

    # æ£€æŸ¥Pythonç‰ˆæœ¬
    print(f"ğŸ“ Pythonç‰ˆæœ¬: {sys.version.split()[0]}")
    print(f"ğŸ“ å½“å‰ç›®å½•: {os.getcwd()}")

    # æ£€æŸ¥é¡¹ç›®ç»“æ„
    project_root = Path(__file__).parent
    bot_dir = project_root / "energy_rental_bot"

    if not bot_dir.exists():
        print("âŒ é”™è¯¯: æœªæ‰¾åˆ° energy_rental_bot ç›®å½•")
        return

    print("âœ… é¡¹ç›®ç»“æ„æ£€æŸ¥é€šè¿‡")

    # æ£€æŸ¥ä¾èµ–
    try:
        import telegram
        print("âœ… python-telegram-bot å·²å®‰è£…")
    except ImportError:
        print("âš ï¸  python-telegram-bot æœªå®‰è£…ï¼Œæ­£åœ¨å®‰è£…...")
        subprocess.run([sys.executable, "-m", "pip", "install", "python-telegram-bot"], check=True)
        print("âœ… python-telegram-bot å®‰è£…å®Œæˆ")

    # è®¾ç½®æ¼”ç¤ºç¯å¢ƒå˜é‡
    os.environ['TELEGRAM_BOT_TOKEN'] = 'demo_token_123'
    os.environ['DB_HOST'] = 'localhost'
    os.environ['DB_NAME'] = 'energy_bot_demo'
    os.environ['DB_USER'] = 'demo_user'
    os.environ['DB_PASSWORD'] = 'demo_pass'

    print("\nğŸ”§ å·²è®¾ç½®æ¼”ç¤ºç¯å¢ƒå˜é‡")

    # è¿è¡Œæµ‹è¯•
    print("\nğŸ§ª è¿è¡Œé…ç½®æµ‹è¯•...")
    result = subprocess.run([sys.executable, str(project_root / "run_bot.py"), "--test"], capture_output=True, text=True)

    if result.returncode == 0:
        print("âœ… æœºå™¨äººé…ç½®æµ‹è¯•é€šè¿‡ï¼")
        print("\nğŸ‰ æ­å–œï¼èƒ½é‡ç§Ÿèµæœºå™¨äººå·²å‡†å¤‡å°±ç»ª")
        print("\nğŸ“ ä¸‹ä¸€æ­¥:")
        print("1. ç¼–è¾‘ .env æ–‡ä»¶ï¼Œè®¾ç½®çœŸå®çš„é…ç½®")
        print("2. è¿è¡Œ: python run_bot.py")
        print("3. åœ¨ Telegram ä¸­ä¸æœºå™¨äººäº¤äº’")
    else:
        print("âŒ é…ç½®æµ‹è¯•å¤±è´¥:")
        print(result.stderr)

if __name__ == "__main__":
    main()
-e 

--- File: ./energy_rental_bot/tasks/get_energy_wallet_trx_trade_task.py ---
"""
è·å–èƒ½é‡é’±åŒ…TRXäº¤æ˜“ä»»åŠ¡
"""

import time
from energy_rental_bot.services.energy_services import EnergyWalletServices, EnergyWalletTradeTrxServices
from energy_rental_bot.utils.energy_utils import EnergyUtils, Concurrent


class GetEnergyWalletTrxTradeTask:
    """è·å–èƒ½é‡é’±åŒ…TRXäº¤æ˜“ä»»åŠ¡"""

    def execute(self):
        """æ‰§è¡Œä»»åŠ¡"""
        wallet_service = EnergyWalletServices()
        wallet_list = wallet_service.get_id_list(3)  # è·å–å®šæ—¶ä»»åŠ¡è¿‡æ»¤çŠ¶æ€çš„é’±åŒ…

        if wallet_list:
            # åç¨‹å¹¶å‘å¤„ç†
            concurrent = Concurrent(5)
            for wallet in wallet_list:
                concurrent.create(lambda w=wallet: self.process_wallet(w))

    def process_wallet(self, wallet):
        """å¤„ç†å•ä¸ªé’±åŒ…"""
        trade_service = EnergyWalletTradeTrxServices()

        # è·å–æœ€åå¤„ç†æ—¶é—´
        start_time = self.get_last_processed_time(wallet['receive_wallet'], 'trx')
        end_time = EnergyUtils.thirteen_time()

        # è·å–tronscanæ•°æ®
        trade_service.get_list(wallet, start_time, end_time)

        # è·å–trongridæ•°æ® (è¿™é‡Œæš‚æ—¶ä½¿ç”¨ç›¸åŒçš„æ–¹æ³•ï¼Œå®é™…åº”è¯¥æœ‰ä¸åŒçš„å®ç°)
        trade_service.get_list(wallet, start_time, end_time)

    def get_last_processed_time(self, wallet_addr, coin_name):
        """è·å–æœ€åå¤„ç†æ—¶é—´"""
        # è¿™é‡Œåº”è¯¥ä»æ•°æ®åº“æŸ¥è¯¢æœ€åå¤„ç†æ—¶é—´
        # æš‚æ—¶è¿”å›1å°æ—¶å‰çš„æ—¶é—´æˆ³
        return (int(time.time()) - 3600) * 1000
-e 

--- File: ./energy_rental_bot/tasks/send_energy_tg_message_task.py ---
"""
å‘é€èƒ½é‡TGæ¶ˆæ¯ä»»åŠ¡
"""

import json
import logging
from urllib.parse import quote
from energy_rental_bot.models.energy_models import (
    EnergyWalletTradeListModel,
    EnergyAiTrusteeshipModel,
    EnergyAiBishuModel
)
from energy_rental_bot.utils.energy_utils import EnergyUtils


class SendEnergyTgMessageTask:
    """å‘é€èƒ½é‡TGæ¶ˆæ¯ä»»åŠ¡"""

    def __init__(self):
        # ä¿®å¤ï¼šåˆå§‹åŒ– logger
        self.logger = logging.getLogger(__name__)

    def execute(self):
        """æ‰§è¡Œä»»åŠ¡"""
        try:
            # è‡ªåŠ©ä¸‹å•æˆåŠŸé€šçŸ¥
            self.send_self_order_notifications()
            # æ™ºèƒ½æ‰˜ç®¡é€šçŸ¥ - å·²ç§»é™¤
            # self.send_trusteeship_notifications()
            # ç¬”æ•°å¥—é¤é€šçŸ¥
            self.send_bishu_notifications()
        except Exception as e:
            self.logger.error(f"å‘é€æ¶ˆæ¯ä»»åŠ¡æ‰§è¡Œå¼‚å¸¸: {str(e)}")

    def send_order_notification(self, order, order_type, status):
        """å‘é€è®¢å•çŠ¶æ€é€šçŸ¥"""
        try:
            message = self.build_order_message(order, order_type, status)
            keyboard = self.build_keyboard(order)
            self.send_to_telegram(order['bot_token'], order['tg_uid'], message, keyboard)
        except Exception as e:
            self.logger.error(f"å‘é€è®¢å•é€šçŸ¥å¼‚å¸¸: {str(e)}")

    def send_self_order_notifications(self):
        """å‘é€è‡ªåŠ©ä¸‹å•é€šçŸ¥"""
        model = EnergyWalletTradeListModel()
        notifications = model.get_tg_notifications('self_order')

        for item in notifications:
            self.send_tg_message(item, 'self_order')
            self.update_notification_status(item['rid'], 'receive')
            self.update_notification_status(item['rid'], 'send')

    def send_trusteeship_notifications(self):
        """å‘é€æ™ºèƒ½æ‰˜ç®¡é€šçŸ¥ - å·²ç¦ç”¨"""
        # æ™ºèƒ½æ‰˜ç®¡åŠŸèƒ½å·²ç§»é™¤ï¼Œä¸å†å‘é€é€šçŸ¥
        pass

    def send_bishu_notifications(self):
        """å‘é€ç¬”æ•°å¥—é¤é€šçŸ¥"""
        model = EnergyAiBishuModel()
        notifications = model.get_for_notification()

        for item in notifications:
            self.send_tg_message(item, 'bishu')
            self.update_bishu_notification_status(item['rid'])

    def send_tg_message(self, item, message_type):
        """å‘é€TGæ¶ˆæ¯"""
        if not item:
            self.logger.error("å‘é€TGæ¶ˆæ¯å¤±è´¥ï¼šitemä¸ºç©º")
            return

        message = self.build_message(item, message_type)
        keyboard = self.build_keyboard(item)

        # å‘é€åˆ°Telegram
        chat_id = item.get('chat_id') or item.get('tg_uid')
        bot_token = item.get('bot_token')

        if not chat_id or not bot_token:
            self.logger.error(f"å‘é€TGæ¶ˆæ¯å¤±è´¥ï¼šç¼ºå°‘å¿…è¦å­—æ®µ chat_id={chat_id}, bot_token={bot_token}")
            return

        self.send_to_telegram(bot_token, chat_id, message, keyboard)

    def build_message(self, item, message_type):
        """æ„å»ºæ¶ˆæ¯å†…å®¹"""
        if not item:
            return "âš ï¸ æ¶ˆæ¯æ•°æ®å¼‚å¸¸"

        if message_type == 'self_order':
            return (
                "ğŸ”‹<b>æ–°çš„èƒ½é‡è®¢å•æˆåŠŸ</b> \n"
                "â–â–â–â–â–â–â–â–\n"
                "<b>ä¸‹å•æ¨¡å¼</b>ï¼šè‡ªåŠ©ä¸‹å•\n"
                f"<b>èƒ½é‡æ•°é‡</b>ï¼š{item.get('energy_amount', 'æœªçŸ¥')}\n"
                f"<b>èƒ½é‡åœ°å€</b>ï¼š{EnergyUtils.format_address(item.get('wallet_addr', 'æœªçŸ¥'))}\n\n"
                "<b>èƒ½é‡å·²ç»åˆ°è´¦ï¼è¯·åœ¨æ—¶é—´èŒƒå›´å†…ä½¿ç”¨ï¼</b>\n"
                "å‘é€ /buyenergy ç»§ç»­è´­ä¹°èƒ½é‡ï¼\n"
                "â–â–â–â–â–â–â–â–"
            )
        elif message_type == 'trusteeship':
            return (
                "ğŸ”‹<b>æ–°çš„èƒ½é‡è®¢å•æˆåŠŸ</b> \n"
                "<b>ä¸‹å•æ¨¡å¼</b>ï¼šæ™ºèƒ½æ‰˜ç®¡\n"
                f"<b>èƒ½é‡æ•°é‡</b>ï¼š{item.get('per_buy_energy_quantity', 'æœªçŸ¥')}\n"
                f"<b>èƒ½é‡åœ°å€</b>ï¼š{EnergyUtils.format_address(item.get('wallet_addr', 'æœªçŸ¥'))}\n\n"
                "<b>èƒ½é‡å·²ç»åˆ°è´¦ï¼è¯·åœ¨æ—¶é—´èŒƒå›´å†…ä½¿ç”¨ï¼</b>\n"
                "âš ï¸<u>é¢„è®¡å‰©ä½™ï¼š</u>è®¡ç®—å‰©ä½™æ¬¡æ•°\n"
                "â–â–â–â–â–â–â–â–"
            )
        elif message_type == 'bishu':
            return (
                "ğŸ–Œ<b>æ–°çš„ç¬”æ•°èƒ½é‡è®¢å•æˆåŠŸ</b> \n"
                "<b>ä¸‹å•æ¨¡å¼</b>ï¼šç¬”æ•°å¥—é¤\n"
                f"<b>èƒ½é‡æ•°é‡</b>ï¼š{item.get('per_bishu_energy_quantity', 'æœªçŸ¥')}\n"
                f"<b>èƒ½é‡åœ°å€</b>ï¼š{EnergyUtils.format_address(item.get('wallet_addr', 'æœªçŸ¥'))}\n\n"
                "<b>èƒ½é‡å·²ç»åˆ°è´¦ï¼è¯·åœ¨æ—¶é—´èŒƒå›´å†…ä½¿ç”¨ï¼</b>\n"
                "âš ï¸<u>é¢„è®¡å‰©ä½™ï¼š</u>è®¡ç®—å‰©ä½™æ¬¡æ•°\n"
                "â–â–â–â–â–â–â–â–"
            )
        else:
            return ''

    def build_order_message(self, order, order_type, status):
        """æ„å»ºè®¢å•æ¶ˆæ¯"""
        if status == 'success':
            return (
                "âœ…<b>AIèƒ½é‡è®¢å•æˆåŠŸ</b> \n"
                f"<b>ä¸‹å•æ¨¡å¼</b>ï¼š{'æ™ºèƒ½æ‰˜ç®¡' if order_type == 'trusteeship' else 'ç¬”æ•°å¥—é¤'}\n"
                f"<b>èƒ½é‡åœ°å€</b>ï¼š{EnergyUtils.format_address(order['wallet_addr'])}\n\n"
                "èƒ½é‡å·²è‡ªåŠ¨è¡¥å……ï¼"
            )
        else:
            return (
                "âŒ<b>AIèƒ½é‡è®¢å•å¤±è´¥</b> \n"
                f"<b>ä¸‹å•æ¨¡å¼</b>ï¼š{'æ™ºèƒ½æ‰˜ç®¡' if order_type == 'trusteeship' else 'ç¬”æ•°å¥—é¤'}\n"
                f"<b>å¤±è´¥åŸå› </b>ï¼š{order.get('comments', 'æœªçŸ¥é”™è¯¯')}"
            )

    def build_keyboard(self, item):
        """æ„å»ºé”®ç›˜"""
        if not item:
            return None

        bot_username = item.get("bot_username", "energybot")
        admin_username = item.get("bot_admin_username", "@admin")

        # ä¿®å¤ admin_username å¯èƒ½ä¸º None çš„æƒ…å†µ
        if not admin_username:
             admin_username = "@admin"

        admin_link = admin_username[1:] if admin_username.startswith("@") else admin_username

        return {
            'inline_keyboard': [
                [
                    {'text': 'èƒ½é‡é—ªç§Ÿ', 'url': f'https://t.me/{bot_username}'},
                    {'text': 'ç¬”æ•°å¥—é¤', 'url': f'https://t.me/{bot_username}'}
                ],
                [
                    {'text': 'è”ç³»å®¢æœ', 'url': f'https://t.me/{admin_link}'},
                    {'text': 'TRXé¢„æ”¯', 'url': f'https://t.me/{admin_link}'}
                ]
            ]
        }

    def send_to_telegram(self, bot_token, chat_id, message, keyboard):
        """å‘é€æ¶ˆæ¯åˆ°Telegram"""
        try:
            url = (
                f"https://api.telegram.org/bot{bot_token}/sendMessage"
                f"?chat_id={chat_id}&text={quote(message)}&parse_mode=HTML&reply_markup={quote(json.dumps(keyboard))}"
            )
            # ä½¿ç”¨ GET è¯·æ±‚é€šå¸¸æ›´ç¨³å®šç”¨äºç®€å•å‘é€ï¼Œæˆ–è€…ç¡®ä¿ POST æ•°æ®æ­£ç¡®
            EnergyUtils.send_http_request(url)
        except Exception as e:
            self.logger.error(f"HTTPè¯·æ±‚å‘é€å¤±è´¥: {str(e)}")

    def update_notification_status(self, rid, status_type):
        """æ›´æ–°é€šçŸ¥çŠ¶æ€"""
        model = EnergyWalletTradeListModel()
        model.update(rid, {f'tg_notice_status_{status_type}': 'Y'})

    def update_trusteeship_notification_status(self, rid):
        """æ›´æ–°æ™ºèƒ½æ‰˜ç®¡é€šçŸ¥çŠ¶æ€"""
        model = EnergyAiTrusteeshipModel()
        model.update(rid, {'is_notice': 'N', 'is_notice_admin': 'N'})

    def update_bishu_notification_status(self, rid):
        """æ›´æ–°ç¬”æ•°å¥—é¤é€šçŸ¥çŠ¶æ€"""
        model = EnergyAiBishuModel()
        model.update(rid, {'is_notice': 'N', 'is_notice_admin': 'N'})
-e 

--- File: ./energy_rental_bot/tasks/__init__.py ---
"""
ä»»åŠ¡åŒ…
"""
-e 

--- File: ./energy_rental_bot/tasks/handle_energy_order_task.py ---
"""
å¤„ç†èƒ½é‡è®¢å•ä»»åŠ¡
"""

import json
import hashlib
import time
from energy_rental_bot.models.energy_models import (
    EnergyWalletTradeListModel,
    EnergyPlatformModel,
    EnergyPlatformPackageModel,
    EnergyAiBishuModel,
    EnergyPlatformOrderModel
)
from energy_rental_bot.services.energy_services import EnergyWalletServices
from energy_rental_bot.utils.energy_utils import EnergyUtils


class HandleEnergyOrderTask:
    """å¤„ç†èƒ½é‡è®¢å•ä»»åŠ¡"""

    def execute(self):
        """æ‰§è¡Œä»»åŠ¡"""
        try:
            # TRXé—ªç§Ÿèƒ½é‡
            self.handle_trx_energy_orders()
            # USDTç¬”æ•°å¥—é¤
            self.handle_usdt_energy_orders()
        except Exception as e:
            EnergyUtils.log('HANDLE_ENERGY_ORDER', f'ä»»åŠ¡æ‰§è¡ŒæŠ¥é”™ï¼š{str(e)}')

    def handle_trx_energy_orders(self):
        """å¤„ç†TRXèƒ½é‡è®¢å•"""
        wallet_service = EnergyWalletServices()
        wallet_list = wallet_service.get_id_list(2)

        if wallet_list:
            current_time = EnergyUtils.now_date()
            for wallet_addr, wallet_info in wallet_list.items():
                platform_bot_rid = wallet_info['rid']

                # è·å–å¾…å¤„ç†çš„TRXäº¤æ˜“
                pending_transactions = self.get_pending_trx_transactions(wallet_addr)

                for transaction in pending_transactions:
                    self.process_trx_transaction(transaction, platform_bot_rid, current_time)

    def handle_usdt_energy_orders(self):
        """å¤„ç†USDTç¬”æ•°å¥—é¤è®¢å•"""
        wallet_service = EnergyWalletServices()
        wallet_list = wallet_service.get_id_list(2)

        if wallet_list:
            current_time = EnergyUtils.now_date()
            for wallet_addr, wallet_info in wallet_list.items():
                bot_rid = wallet_info['rid']

                # è·å–å¾…å¤„ç†çš„USDTäº¤æ˜“
                pending_transactions = self.get_pending_usdt_transactions(wallet_addr)

                for transaction in pending_transactions:
                    self.process_usdt_transaction(transaction, bot_rid, current_time)

    def get_pending_trx_transactions(self, wallet_addr):
        """è·å–å¾…å¤„ç†çš„TRXäº¤æ˜“"""
        model = EnergyWalletTradeListModel()
        return model.get_pending_transactions('trx', wallet_addr)

    def get_pending_usdt_transactions(self, wallet_addr):
        """è·å–å¾…å¤„ç†çš„USDTäº¤æ˜“"""
        model = EnergyWalletTradeListModel()
        return model.get_pending_transactions('usdt', wallet_addr)

    def process_trx_transaction(self, transaction, platform_bot_rid, current_time):
        """å¤„ç†TRXäº¤æ˜“"""
        # åŒ¹é…é‡‘é¢å¯¹åº”çš„å¥—é¤
        package_model = EnergyPlatformPackageModel()
        package = package_model.get_by_trx_price(transaction['bot_rid'], transaction['amount'])

        if not package:
            self.update_transaction_status(transaction['rid'], 7, 'é‡‘é¢æ— å¯¹åº”å¥—é¤', current_time)
            return

        energy_amount = package['energy_amount']

        # è½®è¯¢è·å–å¯ç”¨å¹³å°
        platform_model = EnergyPlatformModel()
        available_platforms = platform_model.get_available_platforms(energy_amount, transaction['poll_group'])

        if not available_platforms:
            self.update_transaction_status(transaction['rid'], 4, 'æœºå™¨äººæ— å¯ç”¨èƒ½é‡å¹³å°', current_time)
            return

        # å°è¯•ä¸‹å•
        for platform in available_platforms:
            result = self.place_energy_order(platform, transaction['transferfrom_address'], energy_amount, package['energy_day'])

            if result['success']:
                self.create_platform_order(platform, transaction, energy_amount, package, current_time)
                self.update_transaction_status(transaction['rid'], 9, 'SUCCESS', current_time, platform['rid'], package['rid'])
                break

    def process_usdt_transaction(self, transaction, bot_rid, current_time):
        """å¤„ç†USDTäº¤æ˜“"""
        # æŸ¥è¯¢ç¬”æ•°å¥—é¤é’±åŒ…æ˜¯å¦å­˜åœ¨
        bishu_model = EnergyAiBishuModel()
        bishu_wallet = bishu_model.get_by_wallet_addr(transaction['transferfrom_address'])

        if bishu_wallet and 'total_buy_usdt' in bishu_wallet:
            # æ›´æ–°è´­ä¹°ç»Ÿè®¡
            update_data = {
                'total_buy_usdt': bishu_wallet.get('total_buy_usdt', 0) + transaction['amount'],
                'max_buy_quantity': bishu_wallet.get('max_buy_quantity', 0) + int(transaction['amount'] / transaction.get('per_bishu_usdt_price', 1))
            }
            bishu_model.update(bishu_wallet['rid'], update_data)
        else:
            # åˆ›å»ºæ–°çš„ç¬”æ•°å¥—é¤é’±åŒ…
            insert_data = {
                'bot_rid': bot_rid,
                'wallet_addr': transaction['transferfrom_address'],
                'status': 0,
                'total_buy_usdt': transaction['amount'],
                'max_buy_quantity': int(transaction['amount'] / transaction.get('per_bishu_usdt_price', 1)),
                'create_time': current_time
            }
            bishu_model.insert(insert_data)

        self.update_transaction_status(transaction['rid'], 9, 'ç¬”æ•°å¥—é¤è´­ä¹°æˆåŠŸ', current_time)

    def place_energy_order(self, platform, address, energy_amount, energy_day):
        """è°ƒç”¨ç›¸åº”å¹³å°çš„APIä¸‹å•"""
        # æ ¹æ®å¹³å°ç±»å‹è°ƒç”¨ä¸åŒçš„API
        platform_name = platform['platform_name']

        if platform_name == 1:  # nee.cc
            return self.place_nee_order(platform, address, energy_amount, energy_day)
        elif platform_name == 2:  # RentEnergysBot
            return self.place_rent_energy_order(platform, address, energy_amount, energy_day)
        elif platform_name == 3:  # è‡ªå·±è´¨æŠ¼
            return self.place_self_stake_order(platform, address, energy_amount)
        elif platform_name == 4:  # trongas.io
            return self.place_trongas_order(platform, address, energy_amount, energy_day)
        else:
            return {'success': False, 'message': 'ä¸æ”¯æŒçš„å¹³å°ç±»å‹'}

    def place_nee_order(self, platform, address, energy_amount, energy_day):
        """è°ƒç”¨nee.cc API"""
        param = {
            "uid": platform['platform_uid'],
            "resource_type": "0",
            "receive_address": address,
            "amount": str(energy_amount),
            "freeze_day": str(energy_day),
            "time": str(int(time.time()))
        }

        # æ·»åŠ ç­¾å
        sorted_param = sorted(param.items())
        sign_str = ''.join([f"{k}{v}" for k, v in sorted_param if k not in ["sign", "sign_type"] and v != ''])
        param['sign'] = hashlib.md5(sign_str.encode()).hexdigest()

        url = 'https://api.tronqq.com/openapi/v2/order/submit'
        response = EnergyUtils.send_http_request(url, json.dumps(param), {'Content-Type': 'application/json'})

        if response:
            try:
                result = json.loads(response)
                if result.get('status') == 200:
                    return {'success': True, 'order_no': result['data']['order_no']}
                else:
                    return {'success': False, 'message': result.get('msg', 'ä¸‹å•å¤±è´¥')}
            except json.JSONDecodeError:
                return {'success': False, 'message': 'APIå“åº”è§£æå¤±è´¥'}
        else:
            return {'success': False, 'message': 'APIè¯·æ±‚å¤±è´¥'}

    def place_rent_energy_order(self, platform, address, energy_amount, energy_day):
        """è°ƒç”¨RentEnergysBot API"""
        energy_type = 'day' if energy_day == 1 else ('3day' if energy_day == 3 else 'hour')
        energy_amount = max(energy_amount, 33000)

        url = (
            f"https://api.wallet.buzz?api=getEnergy&apikey={platform['platform_apikey']}"
            f"&address={address}&amount={energy_amount}&type={energy_type}"
        )

        response = EnergyUtils.send_http_request(url)

        if response:
            try:
                result = json.loads(response)
                if result.get('status') == 'success':
                    return {'success': True, 'txid': result['txid']}
                else:
                    return {'success': False, 'message': 'ä¸‹å•å¤±è´¥'}
            except json.JSONDecodeError:
                return {'success': False, 'message': 'APIå“åº”è§£æå¤±è´¥'}
        else:
            return {'success': False, 'message': 'APIè¯·æ±‚å¤±è´¥'}

    def place_self_stake_order(self, platform, address, energy_amount):
        """è‡ªå·±è´¨æŠ¼ä»£ç†"""
        params = {
            'pri': platform['platform_apikey'],
            'fromaddress': platform['platform_uid'],
            'receiveaddress': address,
            'resourcename': 'ENERGY',
            'resourceamount': energy_amount,
            'resourcetype': 1,
            'permissionid': platform['permission_id']
        }

        response = EnergyUtils.send_http_request('energy_stake_api_url', params)

        if response:
            try:
                result = json.loads(response)
                if result.get('code') == 200:
                    return {
                        'success': True,
                        'txid': result['data']['txid'],
                        'use_trx': result['data']['use_trx']
                    }
                else:
                    return {'success': False, 'message': 'è´¨æŠ¼å¤±è´¥'}
            except json.JSONDecodeError:
                return {'success': False, 'message': 'APIå“åº”è§£æå¤±è´¥'}
        else:
            return {'success': False, 'message': 'APIè¯·æ±‚å¤±è´¥'}

    def place_trongas_order(self, platform, address, energy_amount, energy_day):
        """è°ƒç”¨trongas.io API"""
        rent_time = energy_day if energy_day == 1 else (72 if energy_day == 3 else 1)

        param = {
            "username": platform['platform_uid'],
            "password": platform['platform_apikey'],
            "resType": "ENERGY",
            "payNums": energy_amount,
            "rentTime": rent_time,
            "resLock": 0,
            "receiveAddress": address
        }

        url = 'https://trongas.io/api/pay'
        response = EnergyUtils.send_http_request(url, param)

        if response:
            try:
                result = json.loads(response)
                if result.get('code') == 10000:
                    return {
                        'success': True,
                        'order_id': result['data']['orderId'],
                        'order_money': result['data']['orderMoney']
                    }
                else:
                    return {'success': False, 'message': 'ä¸‹å•å¤±è´¥'}
            except json.JSONDecodeError:
                return {'success': False, 'message': 'APIå“åº”è§£æå¤±è´¥'}
        else:
            return {'success': False, 'message': 'APIè¯·æ±‚å¤±è´¥'}

    def create_platform_order(self, platform, transaction, energy_amount, package, current_time):
        """åˆ›å»ºå¹³å°è®¢å•"""
        order_data = {
            'energy_platform_rid': platform['rid'],
            'energy_platform_bot_rid': transaction['platform_bot_rid'],
            'platform_name': platform['platform_name'],
            'platform_uid': platform['platform_uid'],
            'receive_address': transaction['transferfrom_address'],
            'platform_order_id': transaction.get('order_no', ''),
            'energy_amount': energy_amount,
            'energy_day': package['energy_day'],
            'energy_time': current_time,
            'source_type': 2,  # è‡ªåŠ¨ä¸‹å•
            'recovery_status': 2 if platform['platform_name'] == 3 else 1,
            'use_trx': transaction.get('use_trx', 0)
        }

        order_model = EnergyPlatformOrderModel()
        return order_model.insert(order_data)

    def update_transaction_status(self, rid, status, comments, current_time, platform_rid=None, package_rid=None):
        """æ›´æ–°äº¤æ˜“çŠ¶æ€"""
        update_data = {
            'process_status': status,
            'process_comments': comments,
            'process_time': current_time
        }

        if platform_rid:
            update_data['energy_platform_rid'] = platform_rid

        if package_rid:
            update_data['energy_package_rid'] = package_rid

        model = EnergyWalletTradeListModel()
        model.update(rid, update_data)
-e 

--- File: ./energy_rental_bot/tasks/get_ai_trusteeship_wallet_resource_task.py ---
"""
è·å–AIæ‰˜ç®¡é’±åŒ…èµ„æºä»»åŠ¡
"""

import json
import time
from energy_rental_bot.models.energy_models import EnergyAiTrusteeshipModel, EnergyAiBishuModel
from energy_rental_bot.utils.energy_utils import EnergyUtils, Concurrent


class GetAiTrusteeshipWalletResourceTask:
    """è·å–AIæ‰˜ç®¡é’±åŒ…èµ„æºä»»åŠ¡"""

    def execute(self):
        """æ‰§è¡Œä»»åŠ¡"""
        # æ™ºèƒ½æ‰˜ç®¡
        self.check_trusteeship_wallets()
        # ç¬”æ•°å¥—é¤
        self.check_bishu_wallets()

    def check_trusteeship_wallets(self):
        """æ£€æŸ¥æ™ºèƒ½æ‰˜ç®¡é’±åŒ…"""
        model = EnergyAiTrusteeshipModel()
        wallet_list = model.get_list_for_resource_check()

        concurrent = Concurrent(5)
        for wallet in wallet_list:
            concurrent.create(lambda w=wallet: self.check_wallet_resource(w, 'trusteeship'))

    def check_bishu_wallets(self):
        """æ£€æŸ¥ç¬”æ•°å¥—é¤é’±åŒ…"""
        model = EnergyAiBishuModel()
        wallet_list = model.get_list_for_resource_check()

        concurrent = Concurrent(5)
        for wallet in wallet_list:
            concurrent.create(lambda w=wallet: self.check_wallet_resource(w, 'bishu'))

    def check_wallet_resource(self, wallet, wallet_type):
        """æ£€æŸ¥é’±åŒ…èµ„æº"""
        # é¿å…APIé™åˆ¶
        time.sleep(1)

        # è°ƒç”¨tronscan APIæ£€æŸ¥é’±åŒ…èµ„æº
        url = f'https://apilist.tronscanapi.com/api/accountv2?address={wallet["wallet_addr"]}'
        api_key = EnergyUtils.get_random_api_key('tronapikey')
        headers = {"TRON-PRO-API-KEY": api_key}

        response = EnergyUtils.send_http_request(url, headers=headers)

        if response:
            try:
                data = json.loads(response)
                if 'bandwidth' in data:
                    # åªå¤„ç†æ¿€æ´»çš„åœ°å€
                    is_active = data.get('activated', False)
                    if is_active:
                        bandwidth = data['bandwidth'].get('freeNetRemaining', 0) + data['bandwidth'].get('netRemaining', 0)
                        energy = data['bandwidth'].get('energyRemaining', 0)

                        update_data = {
                            'current_bandwidth_quantity': bandwidth,
                            'current_energy_quantity': energy
                        }

                        # æ£€æŸ¥æ˜¯å¦éœ€è¦è‡ªåŠ¨è´­ä¹°
                        threshold = (
                            wallet['min_energy_quantity']
                            if wallet_type == 'trusteeship'
                            else wallet['per_bishu_energy_quantity']
                        )

                        if energy < threshold and wallet.get('is_buy') == 'N':
                            update_data['is_buy'] = 'Y'

                        # æ›´æ–°æ•°æ®åº“
                        if wallet_type == 'trusteeship':
                            model = EnergyAiTrusteeshipModel()
                        else:
                            model = EnergyAiBishuModel()

                        model.update(wallet['rid'], update_data)
            except json.JSONDecodeError:
                EnergyUtils.log('WALLET_RESOURCE_CHECK', f'è§£æé’±åŒ…èµ„æºæ•°æ®å¤±è´¥: {wallet["wallet_addr"]}')
-e 

--- File: ./energy_rental_bot/tasks/handle_ai_energy_order_task.py ---
"""
å¤„ç†AIèƒ½é‡è®¢å•ä»»åŠ¡
"""

import json
import hashlib
import time
from energy_rental_bot.models.energy_models import (
    EnergyAiTrusteeshipModel,
    EnergyAiBishuModel,
    EnergyPlatformModel,
    EnergyPlatformOrderModel
)
from energy_rental_bot.utils.energy_utils import EnergyUtils, RsaServices, Concurrent


class HandleAiEnergyOrderTask:
    """å¤„ç†AIèƒ½é‡è®¢å•ä»»åŠ¡"""

    def execute(self):
        """æ‰§è¡Œä»»åŠ¡"""
        # æ™ºèƒ½æ‰˜ç®¡
        self.handle_trusteeship_orders()
        # ç¬”æ•°å¥—é¤
        self.handle_bishu_orders()

    def handle_trusteeship_orders(self):
        """å¤„ç†æ™ºèƒ½æ‰˜ç®¡è®¢å•"""
        model = EnergyAiTrusteeshipModel()
        orders = model.get_pending_orders('trusteeship')

        for order in orders:
            # æ£€æŸ¥è´­ä¹°é™åˆ¶
            if order['max_buy_quantity'] > 0 and order['max_buy_quantity'] <= order['total_buy_quantity']:
                continue

            # æ£€æŸ¥ç”¨æˆ·ä½™é¢
            if not self.check_user_balance(order):
                continue

            # è·å–å¯ç”¨å¹³å°
            platforms = self.get_available_platforms(order['poll_group'], order['per_buy_energy_quantity'])

            # å°è¯•ä¸‹å•
            self.process_order(order, platforms, 'trusteeship')

    def handle_bishu_orders(self):
        """å¤„ç†ç¬”æ•°å¥—é¤è®¢å•"""
        model = EnergyAiBishuModel()
        orders = model.get_pending_orders('bishu')

        for order in orders:
            # æ£€æŸ¥è´­ä¹°é™åˆ¶
            if order['max_buy_quantity'] > 0 and order['max_buy_quantity'] <= order['total_buy_quantity']:
                continue

            # æ£€æŸ¥èƒ½é‡ä½™é¢
            if not self.check_energy_balance(order):
                continue

            # è·å–å¯ç”¨å¹³å°
            platforms = self.get_available_platforms(order['poll_group'], order['per_bishu_energy_quantity'])

            # å°è¯•ä¸‹å•
            self.process_order(order, platforms, 'bishu')

    def check_user_balance(self, order):
        """æ£€æŸ¥ç”¨æˆ·ä½™é¢"""
        # æ£€æŸ¥ç”¨æˆ·TRXä½™é¢æ˜¯å¦è¶³å¤Ÿ
        price = order['trx_price_energy_32000'] if order['per_buy_energy_quantity'] == 32000 else order['trx_price_energy_65000']

        # æ¨¡æ‹Ÿæ£€æŸ¥ç”¨æˆ·ä½™é¢
        # è¿™é‡Œåº”è¯¥è°ƒç”¨å…·ä½“çš„ä½™é¢æ£€æŸ¥API
        return True  # å‡è®¾ä½™é¢è¶³å¤Ÿ

    def check_energy_balance(self, order):
        """æ£€æŸ¥èƒ½é‡ä½™é¢"""
        # æ£€æŸ¥é’±åŒ…å½“å‰èƒ½é‡æ˜¯å¦ä½äºé˜ˆå€¼
        return order['current_energy_quantity'] < order['per_bishu_energy_quantity']

    def get_available_platforms(self, poll_group, energy_amount):
        """è·å–å¯ç”¨å¹³å°"""
        model = EnergyPlatformModel()
        return model.get_available_platforms(energy_amount, poll_group)

    def process_order(self, order, platforms, order_type):
        """å¤„ç†è®¢å•"""
        rsa = RsaServices()

        for platform in platforms:
            private_key = rsa.private_decrypt(platform['platform_apikey'])

            if not private_key:
                self.update_order_comments(order['rid'], order_type, "å¹³å°ç§é’¥ä¸ºç©º")
                continue

            # æ ‡è®°ä¸ºä¸‹å•ä¸­
            self.update_order_status(order['rid'], order_type, 'B')

            # è°ƒç”¨ç›¸åº”å¹³å°çš„API
            address = order['wallet_addr']
            energy_amount = order['per_buy_energy_quantity'] if order_type == 'trusteeship' else order['per_bishu_energy_quantity']
            energy_day = order.get('per_energy_day', 1)

            result = self.call_platform_api(platform, address, energy_amount, energy_day, private_key)

            if result['success']:
                # åˆ›å»ºå¹³å°è®¢å•
                self.create_platform_order(platform, order, result, order_type)

                # æ›´æ–°ç»Ÿè®¡
                self.update_order_statistics(order, order_type)

                # å‘é€é€šçŸ¥
                self.send_order_notification(order, order_type, 'success')

                break
            else:
                self.update_order_comments(order['rid'], order_type, result['message'])

    def call_platform_api(self, platform, address, energy_amount, energy_day, private_key):
        """è°ƒç”¨å¹³å°API"""
        # è¿™é‡Œåº”è¯¥æ ¹æ®å¹³å°ç±»å‹è°ƒç”¨ä¸åŒçš„API
        # æš‚æ—¶ä½¿ç”¨ç›¸åŒçš„ä¸‹å•é€»è¾‘
        return self.place_energy_order(platform, address, energy_amount, energy_day)

    def create_platform_order(self, platform, order, result, order_type):
        """åˆ›å»ºå¹³å°è®¢å•"""
        order_data = {
            'energy_platform_rid': platform['rid'],
            'energy_platform_bot_rid': order['energy_platform_bot_rid'],
            'platform_name': platform['platform_name'],
            'platform_uid': platform['platform_uid'],
            'receive_address': order['wallet_addr'],
            'platform_order_id': result.get('order_no', ''),
            'energy_amount': order['per_buy_energy_quantity'] if order_type == 'trusteeship' else order['per_bishu_energy_quantity'],
            'energy_day': order.get('per_energy_day', 1),
            'energy_time': EnergyUtils.now_date(),
            'source_type': 3,  # AIè‡ªåŠ¨ä¸‹å•
            'recovery_status': 2 if platform['platform_name'] == 3 else 1,
            'use_trx': result.get('use_trx', 0)
        }

        order_model = EnergyPlatformOrderModel()
        return order_model.insert(order_data)

    def update_order_statistics(self, order, order_type):
        """æ›´æ–°è®¢å•ç»Ÿè®¡"""
        update_data = {
            'is_buy': 'N',  # é‡ç½®è´­ä¹°çŠ¶æ€
            'total_buy_energy_quantity': order['total_buy_energy_quantity'] + (
                order['per_buy_energy_quantity'] if order_type == 'trusteeship' else order['per_bishu_energy_quantity']
            ),
            'total_buy_quantity': order['total_buy_quantity'] + 1,
            'is_notice': 'Y',
            'last_buy_time': EnergyUtils.now_date()
        }

        if order_type == 'trusteeship':
            model = EnergyAiTrusteeshipModel()
        else:
            model = EnergyAiBishuModel()

        model.update(order['rid'], update_data)

    def update_order_status(self, rid, order_type, status):
        """æ›´æ–°è®¢å•çŠ¶æ€"""
        update_data = {'is_buy': status}

        if order_type == 'trusteeship':
            model = EnergyAiTrusteeshipModel()
        else:
            model = EnergyAiBishuModel()

        model.update(rid, update_data)

    def update_order_comments(self, rid, order_type, comments):
        """æ›´æ–°è®¢å•å¤‡æ³¨"""
        update_data = {'comments': f"{EnergyUtils.now_date()} {comments}"}

        if order_type == 'trusteeship':
            model = EnergyAiTrusteeshipModel()
        else:
            model = EnergyAiBishuModel()

        model.update(rid, update_data)

    def send_order_notification(self, order, order_type, status):
        """å‘é€è®¢å•é€šçŸ¥"""
        # å‘é€Telegramé€šçŸ¥
        notify_task = SendEnergyTgMessageTask()
        notify_task.send_order_notification(order, order_type, status)

    def place_energy_order(self, platform, address, energy_amount, energy_day):
        """è°ƒç”¨ç›¸åº”å¹³å°çš„APIä¸‹å•"""
        # è¿™é‡Œä½¿ç”¨ä¸HandleEnergyOrderTaskç›¸åŒçš„ä¸‹å•é€»è¾‘
        # å®é™…åº”è¯¥æ ¹æ®å¹³å°ç±»å‹è°ƒç”¨ä¸åŒçš„API

        platform_name = platform['platform_name']

        if platform_name == 1:  # nee.cc
            return self.place_nee_order(platform, address, energy_amount, energy_day)
        elif platform_name == 2:  # RentEnergysBot
            return self.place_rent_energy_order(platform, address, energy_amount, energy_day)
        elif platform_name == 3:  # è‡ªå·±è´¨æŠ¼
            return self.place_self_stake_order(platform, address, energy_amount)
        elif platform_name == 4:  # trongas.io
            return self.place_trongas_order(platform, address, energy_amount, energy_day)
        else:
            return {'success': False, 'message': 'ä¸æ”¯æŒçš„å¹³å°ç±»å‹'}

    # å„ä¸ªå¹³å°çš„ä¸‹å•å®ç°ä¸HandleEnergyOrderTaskä¸­çš„ç›¸åŒ
    def place_nee_order(self, platform, address, energy_amount, energy_day):
        """nee.ccå¹³å°ä¸‹å•"""
        param = {
            "uid": platform['platform_uid'],
            "resource_type": "0",
            "receive_address": address,
            "amount": str(energy_amount),
            "freeze_day": str(energy_day),
            "time": str(int(time.time()))
        }

        # æ·»åŠ ç­¾å
        sorted_param = sorted(param.items())
        sign_str = ''.join([f"{k}{v}" for k, v in sorted_param if k not in ["sign", "sign_type"] and v != ''])
        param['sign'] = hashlib.md5(sign_str.encode()).hexdigest()

        url = 'https://api.tronqq.com/openapi/v2/order/submit'
        response = EnergyUtils.send_http_request(url, json.dumps(param), {'Content-Type': 'application/json'})

        if response:
            try:
                result = json.loads(response)
                if result.get('status') == 200:
                    return {'success': True, 'order_no': result['data']['order_no']}
                else:
                    return {'success': False, 'message': result.get('msg', 'ä¸‹å•å¤±è´¥')}
            except json.JSONDecodeError:
                return {'success': False, 'message': 'APIå“åº”è§£æå¤±è´¥'}
        else:
            return {'success': False, 'message': 'APIè¯·æ±‚å¤±è´¥'}

    def place_rent_energy_order(self, platform, address, energy_amount, energy_day):
        """RentEnergysBotå¹³å°ä¸‹å•"""
        energy_type = 'day' if energy_day == 1 else ('3day' if energy_day == 3 else 'hour')
        energy_amount = max(energy_amount, 33000)

        url = (
            f"https://api.wallet.buzz?api=getEnergy&apikey={platform['platform_apikey']}"
            f"&address={address}&amount={energy_amount}&type={energy_type}"
        )

        response = EnergyUtils.send_http_request(url)

        if response:
            try:
                result = json.loads(response)
                if result.get('status') == 'success':
                    return {'success': True, 'txid': result['txid']}
                else:
                    return {'success': False, 'message': 'ä¸‹å•å¤±è´¥'}
            except json.JSONDecodeError:
                return {'success': False, 'message': 'APIå“åº”è§£æå¤±è´¥'}
        else:
            return {'success': False, 'message': 'APIè¯·æ±‚å¤±è´¥'}

    def place_self_stake_order(self, platform, address, energy_amount):
        """è‡ªå·±è´¨æŠ¼å¹³å°ä¸‹å•"""
        params = {
            'pri': platform['platform_apikey'],
            'fromaddress': platform['platform_uid'],
            'receiveaddress': address,
            'resourcename': 'ENERGY',
            'resourceamount': energy_amount,
            'resourcetype': 1,
            'permissionid': platform['permission_id']
        }

        response = EnergyUtils.send_http_request('energy_stake_api_url', params)

        if response:
            try:
                result = json.loads(response)
                if result.get('code') == 200:
                    return {
                        'success': True,
                        'txid': result['data']['txid'],
                        'use_trx': result['data']['use_trx']
                    }
                else:
                    return {'success': False, 'message': 'è´¨æŠ¼å¤±è´¥'}
            except json.JSONDecodeError:
                return {'success': False, 'message': 'APIå“åº”è§£æå¤±è´¥'}
        else:
            return {'success': False, 'message': 'APIè¯·æ±‚å¤±è´¥'}

    def place_trongas_order(self, platform, address, energy_amount, energy_day):
        """trongas.ioå¹³å°ä¸‹å•"""
        rent_time = energy_day if energy_day == 1 else (72 if energy_day == 3 else 1)

        param = {
            "username": platform['platform_uid'],
            "password": platform['platform_apikey'],
            "resType": "ENERGY",
            "payNums": energy_amount,
            "rentTime": rent_time,
            "resLock": 0,
            "receiveAddress": address
        }

        url = 'https://trongas.io/api/pay'
        response = EnergyUtils.send_http_request(url, param)

        if response:
            try:
                result = json.loads(response)
                if result.get('code') == 10000:
                    return {
                        'success': True,
                        'order_id': result['data']['orderId'],
                        'order_money': result['data']['orderMoney']
                    }
                else:
                    return {'success': False, 'message': 'ä¸‹å•å¤±è´¥'}
            except json.JSONDecodeError:
                return {'success': False, 'message': 'APIå“åº”è§£æå¤±è´¥'}
        else:
            return {'success': False, 'message': 'APIè¯·æ±‚å¤±è´¥'}


# å¯¼å…¥è¿™é‡Œæ˜¯ä¸ºäº†é¿å…å¾ªç¯å¯¼å…¥
from energy_rental_bot.tasks.send_energy_tg_message_task import SendEnergyTgMessageTask
-e 

--- File: ./energy_rental_bot/config/config.py ---
"""
èƒ½é‡ç§Ÿèµæœºå™¨äººé…ç½®æ–‡ä»¶
"""

import os
from pathlib import Path
from dotenv import load_dotenv

# åŠ è½½ç¯å¢ƒå˜é‡
load_dotenv()

# é¡¹ç›®æ ¹ç›®å½•
BASE_DIR = Path(__file__).parent.parent

# æ•°æ®åº“é…ç½®
DATABASE_CONFIG = {
    'host': os.getenv('DB_HOST', 'localhost'),
    'port': int(os.getenv('DB_PORT', 3306)),
    'database': os.getenv('DB_NAME', 'energy_bot'),
    'username': os.getenv('DB_USER', 'root'),
    'password': os.getenv('DB_PASSWORD', 'password')
}

# TRONç½‘ç»œé…ç½®
TRON_CONFIG = {
    'api_keys': {
        'tronapikey': [
            os.getenv('TRON_API_KEY_1', 'key1'),
            os.getenv('TRON_API_KEY_2', 'key2'),
            os.getenv('TRON_API_KEY_3', 'key3')
        ],
        'gridapikey': [
            os.getenv('GRID_API_KEY_1', 'key4'),
            os.getenv('GRID_API_KEY_2', 'key5'),
            os.getenv('GRID_API_KEY_3', 'key6')
        ]
    },
    'networks': {
        'mainnet': 'https://api.trongrid.io',
        'testnet': 'https://api.shasta.trongrid.io'
    }
}

# Telegramé…ç½®
TELEGRAM_CONFIG = {
    'bots': [
        {
            'token': os.getenv('TELEGRAM_BOT_TOKEN', 'your_bot_token'),
            'username': os.getenv('TELEGRAM_BOT_USERNAME', 'energybot'),
            'admin_username': os.getenv('TELEGRAM_ADMIN_USERNAME', '@admin'),
            'admin_uid': os.getenv('TELEGRAM_ADMIN_UID', '')  # ç®¡ç†å‘˜ç”¨æˆ·ID
        }
    ],
    'webhook': {
        'enabled': False,  # æ˜¯å¦å¯ç”¨webhookæ¨¡å¼
        'url': os.getenv('WEBHOOK_URL', ''),
        'port': int(os.getenv('WEBHOOK_PORT', 8443))
    }
}

# ä»»åŠ¡é…ç½®
TASK_CONFIG = {
    'concurrency': {
        'max_workers': 5,
        'timeout': 30
    },
    'intervals': {
        'get_trx_trades': 60,      # æ¯åˆ†é’Ÿè·å–TRXäº¤æ˜“
        'get_usdt_trades': 60,     # æ¯åˆ†é’Ÿè·å–USDTäº¤æ˜“
        'handle_orders': 60,       # æ¯åˆ†é’Ÿå¤„ç†è®¢å•
        'check_resources': 600,    # æ¯10åˆ†é’Ÿæ£€æŸ¥èµ„æº
        'handle_ai_orders': 600,   # æ¯10åˆ†é’Ÿå¤„ç†AIè®¢å•
        'send_notifications': 60   # æ¯åˆ†é’Ÿå‘é€é€šçŸ¥
    }
}

# å¹³å°é…ç½®ç¤ºä¾‹
PLATFORM_CONFIG = {
    'nee_cc': {
        'name': 'nee.cc',
        'platform_id': 1,
        'api_url': 'https://api.tronqq.com/openapi/v2/order/submit'
    },
    'rent_energy': {
        'name': 'RentEnergysBot',
        'platform_id': 2,
        'api_url': 'https://api.wallet.buzz'
    },
    'self_stake': {
        'name': 'è‡ªå·±è´¨æŠ¼',
        'platform_id': 3,
        'api_url': 'energy_stake_api_url'
    },
    'trongas': {
        'name': 'trongas.io',
        'platform_id': 4,
        'api_url': 'https://trongas.io/api/pay'
    }
}

# æ—¥å¿—é…ç½®
LOG_CONFIG = {
    'level': 'INFO',
    'file': '/tmp/energy_rental_bot.log',
    'format': '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    'max_size': 10 * 1024 * 1024,  # 10MB
    'backup_count': 5
}

# ç›‘æ§é…ç½®
MONITOR_CONFIG = {
    'alerts': {
        'low_balance_threshold': 1000,  # ä½™é¢ä¸è¶³å‘Šè­¦é˜ˆå€¼
        'high_error_rate_threshold': 0.1,  # é”™è¯¯ç‡å‘Šè­¦é˜ˆå€¼
        'max_retry_attempts': 3
    },
    'metrics': {
        'enable_prometheus': False,
        'prometheus_port': 8000
    }
}

# èƒ½é‡é—ªç§Ÿé…ç½®
ENERGY_RENT_CONFIG = {
    # èƒ½é‡ä»·æ ¼é…ç½® (TRX -> èƒ½é‡)
    'prices': {
        'with_u': {'trx': 2.5, 'energy': 65000},    # å¯¹æ–¹æœ‰Uçš„æƒ…å†µ
        'without_u': {'trx': 5.0, 'energy': 131000}  # å¯¹æ–¹æ— Uçš„æƒ…å†µ
    },

    # é™åˆ¶é…ç½®
    'max_single_trx': 50.0,        # æœ€é«˜å•ç¬”TRX
    'max_energy': 1300000,         # å¯¹åº”æœ€å¤§èƒ½é‡
    'rent_duration_hours': 1,      # ç§Ÿèµæ—¶é•¿ï¼ˆå°æ—¶ï¼‰

    # æ¥æ”¶åœ°å€ - ä»ç¯å¢ƒå˜é‡è¯»å–
    'receive_wallet': os.getenv('ENERGY_RENT_WALLET', 'TWHNEdk5o5qt84bSbFQKqK8LxVxp5wKxgh'),

    # ç›ˆåˆ©é…ç½®
    'profit_margin': 0.1,          # åˆ©æ¶¦ç‡ 10%
    'platform_fee': 0.05           # å¹³å°æ‰‹ç»­è´¹ 5%
}

# ç¬”æ•°å¥—é¤é…ç½®
BISHA_CONFIG = {
    # ç¬”æ•°å¥—é¤ä»·æ ¼é…ç½® (TRX/ç¬”)
    'price_per_bishu': 4.4,

    # å¯è´­ä¹°çš„ç¬”æ•°é€‰é¡¹
    'available_packages': [15, 20, 30, 50, 100, 200, 300, 500],

    # èƒ½é‡é…ç½®
    'energy_per_bishu': 131000,  # æ¯ç¬”å¯¹åº”çš„èƒ½é‡æ•°é‡
    'energy_recovery_time': 5,   # èƒ½é‡æ¢å¤æ—¶é—´ï¼ˆç§’ï¼‰

    # è‡ªåŠ¨èµ é€é…ç½®
    'auto_gift_trx_threshold': 0.35,  # TRXä½™é¢é˜ˆå€¼
    'auto_gift_bandwidth_threshold': 345,  # å¸¦å®½é˜ˆå€¼
    'auto_gift_amount': 0.35,  # è‡ªåŠ¨èµ é€TRXæ•°é‡

    # æ‰£è´¹è§„åˆ™
    'deduct_after_hours': 24,   # å¤šé•¿æ—¶é—´æœªä½¿ç”¨æ‰£å‡1ç¬”
    'pause_after_hours': 72,    # å¤šé•¿æ—¶é—´æœªä½¿ç”¨è‡ªåŠ¨æš‚åœ

    # æ¥æ”¶åœ°å€
    'receive_wallet': os.getenv('BISHA_WALLET', 'TWHNEdk5o5qt84bSbFQKqK8LxVxp5wKxgh'),

    # å®¢æœé…ç½®
    'customer_service': {
        'admin_username': os.getenv('TELEGRAM_ADMIN_USERNAME', '@admin'),
        'work_hours': 'æ¯å¤© 9:00-18:00',
        'response_time': '24å°æ—¶å†…'
    }
}
-e 

--- File: ./energy_rental_bot/config/__init__.py ---
"""
é…ç½®åŒ…
"""
-e 

--- File: ./energy_rental_bot/__init__.py ---
"""
èƒ½é‡ç§Ÿèµæœºå™¨äººåŒ…
"""

__version__ = "1.0.0"
__author__ = "Energy Rental Bot Team"
-e 

--- File: ./energy_rental_bot/utils/energy_utils.py ---
"""
èƒ½é‡ç§Ÿèµæœºå™¨äººå·¥å…·å‡½æ•°
"""

import time
import math
import requests
import random
from datetime import datetime
import logging
# å¯¼å…¥é…ç½®
from energy_rental_bot.config.config import TRON_CONFIG


class EnergyUtils:
    """å·¥å…·å‡½æ•°é›†åˆ"""

    @staticmethod
    def calculate_amount(amount, decimals):
        """è®¡ç®—é‡‘é¢ï¼ˆå¤„ç†å°æ•°ä½ï¼‰"""
        return amount / math.pow(10, decimals)

    @staticmethod
    def thirteen_time():
        """è·å–åä¸‰ä½æ—¶é—´æˆ³"""
        return int(time.time() * 1000)

    @staticmethod
    def now_date():
        """è·å–å½“å‰æ—¥æœŸæ—¶é—´"""
        return datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    @staticmethod
    def send_http_request(url, data=None, headers=None, method='GET'):
        """å‘é€HTTPè¯·æ±‚"""
        try:
            if headers is None:
                headers = {}

            # è®¾ç½® User-Agent é¿å…éƒ¨åˆ†APIæ‹¦æˆª
            if 'User-Agent' not in headers:
                headers['User-Agent'] = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36'

            if data is not None:
                if method.upper() == 'POST':
                    if isinstance(data, dict):
                        response = requests.post(url, json=data, headers=headers, timeout=10)
                    else:
                        response = requests.post(url, data=data, headers=headers, timeout=10)
                else:
                    response = requests.get(url, params=data, headers=headers, timeout=10)
            else:
                response = requests.get(url, headers=headers, timeout=10)

            # åªæœ‰ 4xx å’Œ 5xx æŠ›å‡ºå¼‚å¸¸
            response.raise_for_status()
            return response.text
        except requests.exceptions.HTTPError as e:
            # è®°å½•å…·ä½“çš„ HTTP é”™è¯¯ï¼Œä½†ä¸ä¸€å®šè¦å´©æºƒ
            EnergyUtils.log('HTTP_ERROR', f'APIè¯·æ±‚è¿”å›é”™è¯¯: {e.response.status_code} - {url}')
            return None
        except Exception as e:
            EnergyUtils.log('HTTP_REQUEST_ERROR', f'è¯·æ±‚å¤±è´¥: {str(e)}')
            return None

    @staticmethod
    def get_random_api_key(key_type):
        """è·å–éšæœºAPIå¯†é’¥"""
        # ä¿®å¤ï¼šä»é…ç½®æ–‡ä»¶è·å– Key
        api_keys = TRON_CONFIG['api_keys']

        if key_type in api_keys:
            keys = api_keys[key_type]
            # è¿‡æ»¤æ‰é»˜è®¤çš„æ— æ•ˆ Key
            valid_keys = [k for k in keys if k and not k.startswith('key')]
            if valid_keys:
                return random.choice(valid_keys)

            # å¦‚æœæ²¡æœ‰æœ‰æ•ˆkeyï¼Œä¸ºäº†æµ‹è¯•ä¸æŠ¥é”™ï¼Œè¿”å›ä¸€ä¸ªå‡keyï¼Œä½†ä¸šåŠ¡é€»è¾‘ä¼šå¤±è´¥
            return 'test_key_please_configure_env'

        return None

    @staticmethod
    def log(title, message):
        """æ—¥å¿—è®°å½•"""
        logging.basicConfig(
            filename='/tmp/energy_log.txt',
            level=logging.INFO,
            format='[%(asctime)s] [%(levelname)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )

        log_message = f'[{title}] {message}'
        logging.info(log_message)
        print(log_message)

    @staticmethod
    def format_address(address):
        """åœ°å€æ ¼å¼åŒ–æ˜¾ç¤º"""
        if len(address) >= 16:
            return address[:8] + '****' + address[-8:]
        return address

    @staticmethod
    def setup_logging():
        """è®¾ç½®æ—¥å¿—é…ç½®"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('/tmp/energy_rental_bot.log'),
                logging.StreamHandler()
            ]
        )


# åç¨‹å¹¶å‘ç±» (æ¨¡æ‹Ÿå¼‚æ­¥å¹¶å‘)
class Concurrent:
    """åç¨‹å¹¶å‘æ‰§è¡Œç±»"""

    def __init__(self, limit):
        self.limit = limit
        self.tasks = []

    def create(self, callable_func):
        """åˆ›å»ºåç¨‹ä»»åŠ¡"""
        # åœ¨Pythonä¸­ï¼Œè¿™é‡Œåº”è¯¥ä½¿ç”¨asyncio
        # è¿™é‡Œæš‚æ—¶ä½¿ç”¨åŒæ­¥æ‰§è¡Œä½œä¸ºæ¨¡æ‹Ÿ
        try:
            callable_func()
        except Exception as e:
            EnergyUtils.log('CONCURRENT_ERROR', f'åç¨‹æ‰§è¡Œå¼‚å¸¸: {str(e)}')


# RSAåŠ å¯†æœåŠ¡ç±» (æ¨¡æ‹Ÿ)
class RsaServices:
    """RSAåŠ å¯†æœåŠ¡"""

    @staticmethod
    def private_decrypt(encrypted_data):
        """ç§é’¥è§£å¯†"""
        # è¿™é‡Œåº”è¯¥å®ç°çœŸå®çš„RSAè§£å¯†
        # æš‚æ—¶è¿”å›åŸæ–‡ä½œä¸ºæ¨¡æ‹Ÿ
        return encrypted_data


# æ•°æ®åº“è¿æ¥ç±» (æ¨¡æ‹Ÿ)
class DatabaseConnection:
    """æ•°æ®åº“è¿æ¥ç±»"""

    def __init__(self, config=None):
        self.config = config or {}
        self.connection = None

    def connect(self):
        """è¿æ¥æ•°æ®åº“"""
        # è¿™é‡Œåº”è¯¥å®ç°çœŸå®çš„æ•°æ®åº“è¿æ¥
        # æš‚æ—¶ä½¿ç”¨æ¨¡æ‹Ÿè¿æ¥
        self.connection = "mock_connection"
        return self.connection

    def query(self, sql, params=None):
        """æ‰§è¡ŒæŸ¥è¯¢"""
        # æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢
        EnergyUtils.log('DATABASE_QUERY', f'æ‰§è¡ŒSQL: {sql}')
        return []

    def execute(self, sql, params=None):
        """æ‰§è¡Œæ›´æ–°"""
        # æ¨¡æ‹Ÿæ•°æ®åº“æ‰§è¡Œ
        EnergyUtils.log('DATABASE_EXECUTE', f'æ‰§è¡ŒSQL: {sql}')
        return 1

    def close(self):
        """å…³é—­è¿æ¥"""
        self.connection = None
-e 

--- File: ./energy_rental_bot/utils/__init__.py ---
"""
å·¥å…·åŒ…
"""
-e 

--- File: ./energy_rental_bot/models/energy_models.py ---
"""
èƒ½é‡ç§Ÿèµæœºå™¨äººæ¨¡å‹ç±»
"""

from .base_model import BaseModel
from energy_rental_bot.utils.energy_utils import EnergyUtils


class EnergyAiBishuModel(BaseModel):
    """èƒ½é‡AIç¬”æ•°æ¨¡å‹"""

    def __init__(self):
        super().__init__('energy_ai_bishu')

    def get_by_wallet_addr(self, wallet_addr):
        """æ ¹æ®é’±åŒ…åœ°å€è·å–ç¬”æ•°å¥—é¤ä¿¡æ¯"""
        sql = "SELECT * FROM energy_ai_bishu WHERE wallet_addr = %s"
        result = self.db.query(sql, [wallet_addr])
        if result:
            return result[0]

        # æ¨¡æ‹Ÿæ•°æ® - å®é™…åº”è¯¥ä»æ•°æ®åº“æŸ¥è¯¢
        return {
            'rid': 1,
            'tg_uid': 'user123',
            'wallet_addr': wallet_addr,
            'bot_token': 'bot_token_here',
            'is_notice_admin': 'N',
            'is_notice': 'Y',
            'tg_admin_uid': 'admin123',
            'tg_notice_obj_send': 'group1,group2',
            'bot_username': 'energybot',
            'bot_admin_username': '@admin',
            'per_bishu_energy_quantity': 50000
        }

    def get_list_for_resource_check(self):
        """è·å–éœ€è¦æ£€æŸ¥èµ„æºçš„ç¬”æ•°å¥—é¤åˆ—è¡¨"""
        sql = """
        SELECT * FROM energy_ai_bishu
        WHERE status = 0 AND is_open_bishu = 'Y' AND is_buy = 'N'
        """
        result = self.db.query(sql)
        if result:
            return result

        # æ¨¡æ‹Ÿæ•°æ®
        return [{
            'rid': 1,
            'wallet_addr': 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t',
            'per_bishu_energy_quantity': 50000,
            'is_buy': 'N',
            'bot_rid': 1,
            'is_open_bishu': 'Y',
            'status': 0,
            'max_buy_quantity': 100,
            'total_buy_quantity': 0,
            'bot_token': 'bot_token_here'
        }]

    def get_pending_orders(self, order_type):
        """è·å–å¾…å¤„ç†çš„ç¬”æ•°å¥—é¤è®¢å•"""
        sql = """
        SELECT * FROM energy_ai_bishu
        WHERE status = 0 AND is_buy = 'Y' AND current_energy_quantity < per_bishu_energy_quantity
        """
        result = self.db.query(sql)
        if result:
            return result

        # æ¨¡æ‹Ÿæ•°æ®
        return [{
            'rid': 1,
            'wallet_addr': 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t',
            'per_bishu_energy_quantity': 50000,
            'current_energy_quantity': 10000,
            'is_buy': 'Y',
            'bot_rid': 1,
            'status': 0,
            'max_buy_quantity': 100,
            'total_buy_quantity': 0,
            'poll_group': 'group1',
            'energy_platform_bot_rid': 1,
            'per_energy_day_bishu': 1,
            'bishu_recovery_type': 'auto',
            'bishu_daili_type': 'energy'
        }]

    def get_for_notification(self):
        """è·å–éœ€è¦é€šçŸ¥çš„ç¬”æ•°å¥—é¤è®°å½•"""
        sql = """
        SELECT * FROM energy_ai_bishu
        WHERE is_notice = 'Y'
        """
        result = self.db.query(sql)
        if result:
            return result

        # æ¨¡æ‹Ÿæ•°æ®
        return [{
            'rid': 1,
            'tg_uid': 'user123',
            'wallet_addr': 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t',
            'per_bishu_energy_quantity': 50000,
            'bot_token': 'bot_token_here',
            'is_notice': 'Y',
            'is_notice_admin': 'N',
            'tg_admin_uid': 'admin123',
            'comments': '',
            'tg_notice_obj_send': 'group1,group2',
            'bot_username': 'energybot',
            'bot_admin_username': '@admin',
            'max_buy_quantity': 100,
            'total_buy_quantity': 10
        }]


class EnergyAiTrusteeshipModel(BaseModel):
    """èƒ½é‡AIæ‰˜ç®¡æ¨¡å‹"""

    def __init__(self):
        super().__init__('energy_ai_trusteeship')

    def get_by_wallet_addr(self, wallet_addr):
        """æ ¹æ®é’±åŒ…åœ°å€è·å–æ‰˜ç®¡ä¿¡æ¯"""
        sql = "SELECT * FROM energy_ai_trusteeship WHERE wallet_addr = %s"
        result = self.db.query(sql, [wallet_addr])
        if result:
            return result[0]

        # æ¨¡æ‹Ÿæ•°æ® - å®é™…åº”è¯¥ä»æ•°æ®åº“æŸ¥è¯¢
        return {
            'rid': 1,
            'tg_uid': 'user123',
            'wallet_addr': wallet_addr,
            'bot_token': 'bot_token_here',
            'is_notice_admin': 'N',
            'is_notice': 'Y',
            'tg_admin_uid': 'admin123',
            'tg_notice_obj_send': 'group1,group2',
            'bot_username': 'energybot',
            'bot_admin_username': '@admin',
            'per_buy_energy_quantity': 50000,
            'current_energy_quantity': 0,
            'total_buy_quantity': 0
        }

    def get_list_for_resource_check(self):
        """è·å–éœ€è¦æ£€æŸ¥èµ„æºçš„æ‰˜ç®¡åˆ—è¡¨"""
        sql = """
        SELECT * FROM energy_ai_trusteeship
        WHERE status = 0 AND is_open_ai_trusteeship = 'Y' AND is_buy = 'N'
        """
        result = self.db.query(sql)
        if result:
            return result

        # æ¨¡æ‹Ÿæ•°æ®
        return [{
            'rid': 1,
            'wallet_addr': 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t',
            'min_energy_quantity': 50000,
            'is_buy': 'N',
            'bot_rid': 1,
            'is_open_ai_trusteeship': 'Y',
            'status': 0,
            'per_buy_energy_quantity': 50000,
            'tg_uid': 'user123',
            'bot_token': 'bot_token_here'
        }]

    def get_pending_orders(self, order_type):
        """è·å–å¾…å¤„ç†çš„AIè®¢å•"""
        sql = """
        SELECT * FROM energy_ai_trusteeship
        WHERE status = 0 AND is_buy = 'Y'
        """
        result = self.db.query(sql)
        if result:
            return result

        # æ¨¡æ‹Ÿæ•°æ®
        return [{
            'rid': 1,
            'wallet_addr': 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t',
            'tg_uid': 'user123',
            'per_buy_energy_quantity': 50000,
            'trx_price_energy_32000': 50,
            'trx_price_energy_65000': 100,
            'per_energy_day': 1,
            'status': 0,
            'is_buy': 'Y',
            'bot_rid': 1,
            'total_buy_energy_quantity': 0,
            'total_used_trx': 0,
            'total_buy_quantity': 0,
            'is_notice_admin': 'N',
            'poll_group': 'group1',
            'energy_platform_bot_rid': 1,
            'max_buy_quantity': 100,
            'is_open_ai_trusteeship': 'Y'
        }]

    def update_resource(self, rid, data):
        """æ›´æ–°èµ„æºçŠ¶æ€"""
        return self.update(rid, data)

    def get_for_notification(self):
        """è·å–éœ€è¦é€šçŸ¥çš„æ•°æ®"""
        sql = """
        SELECT * FROM energy_ai_trusteeship
        WHERE is_notice = 'Y'
        """
        result = self.db.query(sql)
        if result:
            return result

        # æ¨¡æ‹Ÿæ•°æ®
        return [{
            'rid': 1,
            'tg_uid': 'user123',
            'wallet_addr': 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t',
            'per_buy_energy_quantity': 50000,
            'bot_token': 'bot_token_here',
            'is_notice': 'Y',
            'is_notice_admin': 'N',
            'tg_admin_uid': 'admin123',
            'comments': '',
            'tg_notice_obj_send': 'group1,group2',
            'bot_username': 'energybot',
            'bot_admin_username': '@admin'
        }]


class EnergyPlatformModel(BaseModel):
    """èƒ½é‡å¹³å°æ¨¡å‹"""

    def __init__(self):
        super().__init__('energy_platform')

    def get_available_platforms(self, energy_amount, poll_group):
        """è·å–å¯ç”¨å¹³å°åˆ—è¡¨"""
        sql = """
        SELECT * FROM energy_platform
        WHERE status = 0 AND platform_balance >= %s
        ORDER BY seq_sn ASC
        """
        result = self.db.query(sql, [energy_amount])
        if result:
            return result

        # æ¨¡æ‹Ÿæ•°æ®
        return [{
            'rid': 1,
            'platform_name': 1,  # nee.cc
            'platform_uid': 'user123',
            'platform_apikey': 'encrypted_key',
            'platform_balance': 1000000,
            'permission_id': 0,
            'seq_sn': 1
        }]


class EnergyPlatformBotModel(BaseModel):
    """èƒ½é‡å¹³å°æœºå™¨äººæ¨¡å‹"""

    def __init__(self):
        super().__init__('energy_platform_bot')

    def get_list(self, status=0):
        """è·å–æœºå™¨äººåˆ—è¡¨"""
        sql = f"SELECT * FROM energy_platform_bot WHERE status = %s"
        result = self.db.query(sql, [status])
        if result:
            return result

        # æ¨¡æ‹Ÿæ•°æ®
        return [{
            'rid': 1,
            'receive_wallet': 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t',
            'status': 0,
            'get_tx_time': '2024-01-01 00:00:00'
        }]


class EnergyPlatformOrderModel(BaseModel):
    """èƒ½é‡å¹³å°è®¢å•æ¨¡å‹"""

    def __init__(self):
        super().__init__('energy_platform_order')


class EnergyPlatformPackageModel(BaseModel):
    """èƒ½é‡å¹³å°å¥—é¤æ¨¡å‹"""

    def __init__(self):
        super().__init__('energy_platform_package')

    def get_by_trx_price(self, bot_rid, trx_price):
        """æ ¹æ®TRXä»·æ ¼è·å–å¥—é¤"""
        sql = """
        SELECT * FROM energy_platform_package
        WHERE bot_rid = %s AND trx_price = %s AND status = 0
        """
        result = self.db.query(sql, [bot_rid, trx_price])
        if result:
            return result[0]

        # æ¨¡æ‹Ÿæ•°æ®
        return {
            'rid': 1,
            'energy_amount': 50000,
            'energy_day': 1,
            'package_name': '50000èƒ½é‡1å¤©'
        }


class EnergyWalletTradeListModel(BaseModel):
    """èƒ½é‡é’±åŒ…äº¤æ˜“åˆ—è¡¨æ¨¡å‹"""

    def __init__(self):
        super().__init__('energy_wallet_trade_list')

    def get_pending_transactions(self, coin_name=None, wallet_addr=None):
        """è·å–å¾…å¤„ç†çš„äº¤æ˜“"""
        conditions = ["process_status = 1"]
        params = []

        if coin_name:
            conditions.append("coin_name = %s")
            params.append(coin_name)

        if wallet_addr:
            conditions.append("transferto_address = %s")
            params.append(wallet_addr)

        sql = f"SELECT * FROM energy_wallet_trade_list WHERE {' AND '.join(conditions)}"
        result = self.db.query(sql, params)
        if result:
            return result

        # æ¨¡æ‹Ÿæ•°æ®
        return [{
            'rid': 1,
            'transferfrom_address': wallet_addr or 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t',
            'transferto_address': wallet_addr or 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t',
            'amount': 10.5,
            'coin_name': coin_name or 'trx',
            'tx_hash': 'hash123',
            'timestamp': EnergyUtils.thirteen_time(),
            'process_status': 1,
            'bot_rid': 1,
            'poll_group': 'group1',
            'platform_bot_rid': 1
        }]

    def get_tg_notifications(self, notify_type):
        """è·å–éœ€è¦å‘é€TGé€šçŸ¥çš„è®°å½•"""
        status_map = {
            'self_order': "process_status = 9 AND tg_notice_status_receive = 'N'",
            'trusteeship': "process_status = 9 AND tg_notice_status_send = 'N'"
        }

        condition = status_map.get(notify_type, "process_status = 9")
        sql = f"SELECT * FROM energy_wallet_trade_list WHERE {condition}"
        result = self.db.query(sql)
        if result:
            return result

        # æ¨¡æ‹Ÿæ•°æ®
        return [{
            'rid': 1,
            'tx_hash': 'hash123',
            'transferfrom_address': 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t',
            'coin_name': 'trx',
            'amount': 10.5,
            'process_status': 9,
            'tg_notice_status_receive': 'N',
            'tg_notice_status_send': 'N',
            'tg_notice_obj_receive': 'group1,group2',
            'tg_notice_obj_send': 'group1,group2',
            'bot_token': 'bot_token_here',
            'receive_wallet': 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t',
            'energy_amount': 50000,
            'package_name': '50000èƒ½é‡1å¤©',
            'bot_username': 'energybot',
            'bot_admin_username': '@admin',
            'energy_platform_bot_rid': 1
        }]

    def get_by_tx_hash(self, hash_list):
        """æ£€æŸ¥hashæ˜¯å¦å­˜åœ¨"""
        if not hash_list:
            return []

        placeholders = ", ".join(["%s"] * len(hash_list))
        sql = f"SELECT tx_hash FROM energy_wallet_trade_list WHERE tx_hash IN ({placeholders})"
        result = self.db.query(sql, hash_list)
        return [row['tx_hash'] for row in result] if result else []
-e 

--- File: ./energy_rental_bot/models/__init__.py ---
"""
æ¨¡å‹åŒ…
"""
-e 

--- File: ./energy_rental_bot/models/base_model.py ---
"""
èƒ½é‡ç§Ÿèµæœºå™¨äººåŸºç¡€æ¨¡å‹ç±»
"""

from energy_rental_bot.utils.energy_utils import DatabaseConnection, EnergyUtils


class BaseModel:
    """åŸºç¡€æ¨¡å‹ç±»"""

    def __init__(self, table_name):
        self.table = table_name
        self.db = DatabaseConnection()

    def get_by_id(self, rid):
        """æ ¹æ®IDè·å–è®°å½•"""
        sql = f"SELECT * FROM {self.table} WHERE rid = %s"
        result = self.db.query(sql, [rid])
        return result[0] if result else None

    def update(self, rid, data):
        """æ›´æ–°è®°å½•"""
        set_clause = ", ".join([f"{k} = %s" for k in data.keys()])
        values = list(data.values()) + [rid]
        sql = f"UPDATE {self.table} SET {set_clause} WHERE rid = %s"
        return self.db.execute(sql, values)

    def insert(self, data):
        """æ’å…¥è®°å½•"""
        columns = ", ".join(data.keys())
        placeholders = ", ".join(["%s"] * len(data))
        values = list(data.values())
        sql = f"INSERT INTO {self.table} ({columns}) VALUES ({placeholders})"
        return self.db.execute(sql, values)

    def delete(self, rid):
        """åˆ é™¤è®°å½•"""
        sql = f"DELETE FROM {self.table} WHERE rid = %s"
        return self.db.execute(sql, [rid])
-e 

--- File: ./energy_rental_bot/bot/__init__.py ---
"""
Telegram Bot åŒ…
"""
-e 

--- File: ./energy_rental_bot/bot/energy_bot.py ---
"""
èƒ½é‡ç§Ÿèµæœºå™¨äºº - Telegram Bot æ ¸å¿ƒç±»
"""

import asyncio
import logging
import json
from typing import Dict, Any, Optional
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    ContextTypes,
    filters
)

from energy_rental_bot.config.config import TELEGRAM_CONFIG, TASK_CONFIG, ENERGY_RENT_CONFIG, BISHA_CONFIG
from energy_rental_bot.controllers.energy_controller import TrongasIoController
from energy_rental_bot.models.energy_models import (
    EnergyAiBishuModel,
    EnergyAiTrusteeshipModel,
    EnergyWalletTradeListModel
)
from energy_rental_bot.tasks.handle_energy_order_task import HandleEnergyOrderTask
from energy_rental_bot.tasks.get_energy_wallet_trx_trade_task import GetEnergyWalletTrxTradeTask
from energy_rental_bot.tasks.handle_ai_energy_order_task import HandleAiEnergyOrderTask
from energy_rental_bot.tasks.send_energy_tg_message_task import SendEnergyTgMessageTask
from energy_rental_bot.utils.energy_utils import EnergyUtils


class EnergyRentalBot:
    """èƒ½é‡ç§Ÿèµæœºå™¨äººä¸»ç±»"""

    def __init__(self):
        self.application = None
        self.logger = logging.getLogger(__name__)

        # åˆå§‹åŒ–æ§åˆ¶å™¨
        self.trongas_controller = TrongasIoController()

        # ç”¨æˆ·çŠ¶æ€ç®¡ç†
        self.user_states: Dict[int, Dict[str, Any]] = {}

        # ä»»åŠ¡è°ƒåº¦å™¨
        self.scheduler_task = None

    async def initialize(self) -> None:
        """åˆå§‹åŒ–æœºå™¨äºº"""
        try:
            # æ¸…é™¤ç¯å¢ƒå˜é‡ä¸­çš„ä»£ç†è®¾ç½®
            import os
            proxy_vars = ['http_proxy', 'https_proxy', 'all_proxy', 'HTTP_PROXY', 'HTTPS_PROXY', 'ALL_PROXY']
            for var in proxy_vars:
                if var in os.environ:
                    del os.environ[var]

            # åˆ›å»ºåº”ç”¨
            token = TELEGRAM_CONFIG['bots'][0]['token']
            self.application = (
                Application.builder()
                .token(token)
                .post_init(self._post_init)
                .build()
            )

            # æ³¨å†Œå¤„ç†å™¨
            await self._register_handlers()

            self.logger.info("Telegram Bot åˆå§‹åŒ–æˆåŠŸ")

        except Exception as e:
            self.logger.error(f"Bot åˆå§‹åŒ–å¤±è´¥: {str(e)}")
            raise

    async def _post_init(self, application: Application) -> None:
        """æœºå™¨äººå¯åŠ¨åçš„åˆå§‹åŒ–"""
        # å¯åŠ¨åå°ä»»åŠ¡è°ƒåº¦å™¨
        self.scheduler_task = asyncio.create_task(self._scheduler_loop())
        self.logger.info("åå°ä»»åŠ¡è°ƒåº¦å™¨å·²å¯åŠ¨")

    async def _register_handlers(self) -> None:
        """æ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨"""
        if not self.application:
            return

        # å‘½ä»¤å¤„ç†å™¨
        self.application.add_handler(CommandHandler("start", self._handle_start))
        self.application.add_handler(CommandHandler("buyenergy", self._handle_buy_energy))
        self.application.add_handler(CommandHandler("help", self._handle_help))
        self.application.add_handler(CommandHandler("status", self._handle_status))
        self.application.add_handler(CommandHandler("admin", self._handle_admin))

        # å†…è”æŒ‰é’®å¤„ç†å™¨
        self.application.add_handler(CallbackQueryHandler(self._handle_callback))

        # æ–‡æœ¬æ¶ˆæ¯å¤„ç†å™¨ (å¤„ç†é’±åŒ…åœ°å€è¾“å…¥ç­‰)
        self.application.add_handler(MessageHandler(
            filters.TEXT & ~filters.COMMAND,
            self._handle_text_message
        ))

        # é”™è¯¯å¤„ç†å™¨
        self.application.add_error_handler(self._handle_error)

    def start(self) -> None:
        """å¯åŠ¨æœºå™¨äºº"""
        if not self.application:
            # å¦‚æœè¿˜æ²¡æœ‰åˆå§‹åŒ–ï¼Œéœ€è¦åœ¨æ–°çš„äº‹ä»¶å¾ªç¯ä¸­åˆå§‹åŒ–
            asyncio.run(self.initialize())

        self.logger.info("èƒ½é‡ç§Ÿèµæœºå™¨äººå¯åŠ¨ä¸­...")

        # å¯åŠ¨æœºå™¨äºº (è¿™æ˜¯é˜»å¡è°ƒç”¨)
        self.application.run_polling(allowed_updates=Update.ALL_TYPES)

    async def stop(self) -> None:
        """åœæ­¢æœºå™¨äºº"""
        if self.scheduler_task:
            self.scheduler_task.cancel()
            try:
                await self.scheduler_task
            except asyncio.CancelledError:
                pass

        if self.application:
            await self.application.shutdown()

        self.logger.info("èƒ½é‡ç§Ÿèµæœºå™¨äººå·²åœæ­¢")

    async def _scheduler_loop(self) -> None:
        """åå°ä»»åŠ¡è°ƒåº¦å¾ªç¯"""
        self.logger.info("åå°ä»»åŠ¡å¾ªç¯å·²å¼€å§‹")
        while True:
            try:
                current_time = datetime.now()

                # æ¯åˆ†é’Ÿæ‰§è¡Œçš„ä»»åŠ¡
                if current_time.second < 5:  # é¿å…é‡å¤æ‰§è¡Œ
                    # ä½¿ç”¨ asyncio.create_task ä¸é˜»å¡å¾ªç¯
                    asyncio.create_task(self._run_minute_tasks_safe())

                # æ¯10åˆ†é’Ÿæ‰§è¡Œçš„ä»»åŠ¡
                if current_time.minute % 10 == 0 and current_time.second < 5:
                    asyncio.create_task(self._run_ten_minute_tasks_safe())

                await asyncio.sleep(5)  # æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡

            except asyncio.CancelledError:
                self.logger.info("åå°ä»»åŠ¡å¾ªç¯è¢«å–æ¶ˆ")
                break
            except Exception as e:
                self.logger.error(f"è°ƒåº¦å™¨ä¸¥é‡é”™è¯¯: {str(e)}")
                await asyncio.sleep(30)

    # æ·»åŠ æ–°çš„å®‰å…¨æ‰§è¡Œæ–¹æ³• wrapper

    async def _run_minute_tasks_safe(self) -> None:
        """å®‰å…¨è¿è¡Œåˆ†é’Ÿä»»åŠ¡"""
        try:
            await self._run_minute_tasks()
        except Exception as e:
            self.logger.error(f"åˆ†é’Ÿä»»åŠ¡ç»„æ‰§è¡Œå¤±è´¥: {str(e)}")

    async def _run_ten_minute_tasks_safe(self) -> None:
        """å®‰å…¨è¿è¡Œ10åˆ†é’Ÿä»»åŠ¡"""
        try:
            await self._run_ten_minute_tasks()
        except Exception as e:
            self.logger.error(f"10åˆ†é’Ÿä»»åŠ¡ç»„æ‰§è¡Œå¤±è´¥: {str(e)}")

    # ç¨å¾®ä¿®æ”¹ _run_minute_tasksï¼Œå°†å…¶å˜ä¸ºéé˜»å¡ï¼ˆå› ä¸ºåŸæ¥çš„ Task.execute æ˜¯åŒæ­¥çš„ï¼‰

    async def _run_minute_tasks(self) -> None:
        """æ¯åˆ†é’Ÿæ‰§è¡Œçš„ä»»åŠ¡"""
        # å°†åŒæ­¥é˜»å¡ä»»åŠ¡æ”¾åˆ°çº¿ç¨‹æ± ä¸­è¿è¡Œï¼Œé¿å…é˜»å¡ Telegram Bot çš„å¿ƒè·³
        loop = asyncio.get_running_loop()

        await loop.run_in_executor(None, self._execute_minute_logic)

    def _execute_minute_logic(self):
        """åŒæ­¥æ‰§è¡Œçš„åˆ†é’Ÿé€»è¾‘"""
        try:
            # è·å–TRXäº¤æ˜“æ•°æ®
            trx_task = GetEnergyWalletTrxTradeTask()
            trx_task.execute()
        except Exception as e:
            self.logger.error(f"TRXäº¤æ˜“ä»»åŠ¡å¤±è´¥: {e}")

        try:
            # å¤„ç†èƒ½é‡è®¢å•
            order_task = HandleEnergyOrderTask()
            order_task.execute()
        except Exception as e:
            self.logger.error(f"è®¢å•å¤„ç†ä»»åŠ¡å¤±è´¥: {e}")

        try:
            # å‘é€é€šçŸ¥
            notify_task = SendEnergyTgMessageTask()
            notify_task.execute()
        except Exception as e:
            self.logger.error(f"é€šçŸ¥ä»»åŠ¡å¤±è´¥: {e}")

    async def _run_ten_minute_tasks(self) -> None:
        loop = asyncio.get_running_loop()
        await loop.run_in_executor(None, self._execute_ten_minute_logic)

    def _execute_ten_minute_logic(self):
        try:
            # å¤„ç†AIèƒ½é‡è®¢å•
            ai_task = HandleAiEnergyOrderTask()
            ai_task.execute()
        except Exception as e:
             self.logger.error(f"AIè®¢å•ä»»åŠ¡å¤±è´¥: {e}")

    # ===== å‘½ä»¤å¤„ç†å™¨ =====

    async def _handle_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """å¤„ç† /start å‘½ä»¤"""
        user = update.effective_user
        if not user:
            return

        welcome_text = (
            f"ğŸ–Œ <b>æ¬¢è¿ä½¿ç”¨èƒ½é‡ç§Ÿèµæœºå™¨äºº</b>\n\n"
            f"ğŸ‘‹ ä½ å¥½ï¼Œ{user.first_name}ï¼\n\n"
            f"<b>æˆ‘å¯ä»¥å¸®ä½ ï¼š</b>\n"
            f"ğŸ”‹ èƒ½é‡é—ªç§Ÿ\n"
            f"ğŸ“ ç¬”æ•°å¥—é¤æœåŠ¡\n\n"
            f"å‘é€ /buyenergy å¼€å§‹ä½¿ç”¨ï¼\n"
            f"å‘é€ /help æŸ¥çœ‹è¯¦ç»†å¸®åŠ©"
        )

        keyboard = [
            [
                KeyboardButton("ğŸ”‹ èƒ½é‡é—ªç§Ÿ"),
                KeyboardButton("ğŸ“ ç¬”æ•°å¥—é¤")
            ],
            [
                KeyboardButton("ğŸ“Š æˆ‘çš„çŠ¶æ€"),
                KeyboardButton("ğŸ‘¨â€ğŸ’¼ å®¢æœ")
            ]
        ]

        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        await update.message.reply_text(
            welcome_text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _handle_buy_energy(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """å¤„ç† /buyenergy å‘½ä»¤"""
        user = update.effective_user
        if not user:
            return

        # è®¾ç½®ç”¨æˆ·çŠ¶æ€ä¸ºç­‰å¾…é’±åŒ…åœ°å€
        self.user_states[user.id] = {
            'state': 'waiting_wallet_address',
            'action': 'buy_energy'
        }

        text = (
            "ğŸ”‹ <b>èƒ½é‡è´­ä¹°æœåŠ¡</b>\n\n"
            "è¯·é€‰æ‹©è´­ä¹°æ–¹å¼ï¼š\n\n"
            "1ï¸âƒ£ <b>è‡ªåŠ©è´­ä¹°</b>\n"
            "â€¢ å‘é€TRXåˆ°æŒ‡å®šé’±åŒ…\n"
            "â€¢ è‡ªåŠ¨åŒ¹é…èƒ½é‡å¥—é¤\n"
            "â€¢ å®æ—¶åˆ°è´¦é€šçŸ¥\n\n"
            "2ï¸âƒ£ <b>ç¬”æ•°å¥—é¤</b>\n"
            "â€¢ USDTè´­ä¹°å›ºå®šæ¬¡æ•°\n"
            "â€¢ æŒ‰éœ€ä½¿ç”¨æ›´çœé’±\n"
            "â€¢ æ™ºèƒ½è®¡ç®—å‰©ä½™æ¬¡æ•°"
        )

        keyboard = [
            [
                InlineKeyboardButton("1ï¸âƒ£ è‡ªåŠ©è´­ä¹°", callback_data="manual_buy"),
                InlineKeyboardButton("2ï¸âƒ£ ç¬”æ•°å¥—é¤", callback_data="setup_bishu")
            ],
            [
                InlineKeyboardButton("âŒ å–æ¶ˆ", callback_data="cancel")
            ]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _handle_help(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """å¤„ç† /help å‘½ä»¤"""
        help_text = (
            "ğŸ“š <b>èƒ½é‡ç§Ÿèµæœºå™¨äººä½¿ç”¨å¸®åŠ©</b>\n\n"
            "<b>åŸºç¡€å‘½ä»¤ï¼š</b>\n"
            "/start - å¼€å§‹ä½¿ç”¨æœºå™¨äºº\n"
            "/buyenergy - è´­ä¹°èƒ½é‡æœåŠ¡\n"
            "/status - æŸ¥çœ‹æˆ‘çš„çŠ¶æ€\n"
            "/help - æ˜¾ç¤ºæ­¤å¸®åŠ©\n\n"
            "<b>æœåŠ¡è¯´æ˜ï¼š</b>\n\n"
            "ğŸ”‹ <b>è‡ªåŠ©è´­ä¹°</b>\n"
            "å‘æŒ‡å®šé’±åŒ…è½¬è´¦TRXï¼Œè‡ªåŠ¨è´­ä¹°èƒ½é‡\n"
            "æ”¯æŒå¤šç§å¥—é¤ï¼Œå®æ—¶åˆ°è´¦\n\n"
            "ğŸ“ <b>ç¬”æ•°å¥—é¤</b>\n"
            "USDTè´­ä¹°å›ºå®šæ¬¡æ•°çš„èƒ½é‡ä½¿ç”¨æƒ\n"
            "æ›´é€‚åˆå¶å°”ä½¿ç”¨çš„ç”¨æˆ·\n\n"
            "<b>å¸¸è§é—®é¢˜ï¼š</b>\n"
            "â€¢ å¦‚ä½•å¼€å§‹ä½¿ç”¨ï¼Ÿå‘é€ /buyenergy\n"
            "â€¢ èƒ½é‡ä»€ä¹ˆæ—¶å€™åˆ°è´¦ï¼Ÿè´­ä¹°åç«‹å³åˆ°è´¦\n"
            "â€¢ æ˜¯å¦å®‰å…¨ï¼Ÿé‡‡ç”¨å¤šé‡éªŒè¯ï¼Œç¡®ä¿å®‰å…¨"
        )

        await update.message.reply_text(
            help_text,
            parse_mode='HTML'
        )

    async def _handle_status(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """å¤„ç† /status å‘½ä»¤"""
        user = update.effective_user
        if not user:
            return

        # æŸ¥è¯¢ç”¨æˆ·çš„æ‰˜ç®¡å’Œç¬”æ•°å¥—é¤çŠ¶æ€
        trusteeship_model = EnergyAiTrusteeshipModel()
        bishu_model = EnergyAiBishuModel()

        trusteeship_data = trusteeship_model.get_by_wallet_addr(f"user_{user.id}")
        bishu_data = bishu_model.get_by_wallet_addr(f"user_{user.id}")

        status_text = f"ğŸ“Š <b>{user.first_name} çš„è´¦æˆ·çŠ¶æ€</b>\n\n"

        if trusteeship_data:
            status_text += (
                f"ğŸ¤– <b>æ™ºèƒ½æ‰˜ç®¡</b>\n"
                f"çŠ¶æ€ï¼š{'è¿è¡Œä¸­' if trusteeship_data.get('is_buy') == 'N' else 'è´­ä¹°ä¸­'}\n"
                f"å½“å‰èƒ½é‡ï¼š{trusteeship_data.get('current_energy_quantity', 0)}\n"
                f"å·²è´­ä¹°ï¼š{trusteeship_data.get('total_buy_quantity', 0)} æ¬¡\n\n"
            )

        if bishu_data:
            status_text += (
                f"ğŸ“ <b>ç¬”æ•°å¥—é¤</b>\n"
                f"çŠ¶æ€ï¼š{'æ­£å¸¸' if bishu_data.get('is_buy') == 'N' else 'è´­ä¹°ä¸­'}\n"
                f"å½“å‰èƒ½é‡ï¼š{bishu_data.get('current_energy_quantity', 0)}\n"
                f"å·²è´­ä¹°ï¼š{bishu_data.get('total_buy_quantity', 0)} æ¬¡\n"
                f"USDTæ¶ˆè´¹ï¼š{bishu_data.get('total_buy_usdt', 0)}\n\n"
            )

        if not trusteeship_data and not bishu_data:
            status_text += "âŒ æ‚¨è¿˜æ²¡æœ‰è®¾ç½®ä»»ä½•æœåŠ¡\n\nå‘é€ /buyenergy å¼€å§‹ä½¿ç”¨"

        keyboard = [
            [InlineKeyboardButton("ğŸ”„ åˆ·æ–°", callback_data="refresh_status")]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            status_text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _handle_admin(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """å¤„ç† /admin å‘½ä»¤ (ç®¡ç†å‘˜åŠŸèƒ½)"""
        user = update.effective_user
        if not user:
            return

        # æ£€æŸ¥æ˜¯å¦ä¸ºç®¡ç†å‘˜
        admin_uid = TELEGRAM_CONFIG['bots'][0].get('admin_uid')
        if str(user.id) != admin_uid:
            await update.message.reply_text("âŒ æ‚¨æ²¡æœ‰ç®¡ç†å‘˜æƒé™")
            return

        admin_text = (
            "âš™ï¸ <b>ç®¡ç†å‘˜é¢æ¿</b>\n\n"
            "<b>ç³»ç»ŸçŠ¶æ€ï¼š</b>\n"
            "â€¢ æœºå™¨äººè¿è¡Œæ­£å¸¸\n"
            "â€¢ åå°ä»»åŠ¡è¿è¡Œä¸­\n"
            "â€¢ æ•°æ®åº“è¿æ¥æ­£å¸¸\n\n"
            "<b>å¿«æ·æ“ä½œï¼š</b>"
        )

        keyboard = [
            [
                InlineKeyboardButton("ğŸ“ˆ ç³»ç»Ÿç»Ÿè®¡", callback_data="admin_stats"),
                InlineKeyboardButton("ğŸ”§ é…ç½®ç®¡ç†", callback_data="admin_config")
            ],
            [
                InlineKeyboardButton("ğŸ“Š äº¤æ˜“è®°å½•", callback_data="admin_trades"),
                InlineKeyboardButton("ğŸš¨ å¼‚å¸¸å¤„ç†", callback_data="admin_errors")
            ]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            admin_text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    # ===== å†…è”æŒ‰é’®å¤„ç†å™¨ =====

    async def _handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """å¤„ç†å†…è”æŒ‰é’®å›è°ƒ"""
        query = update.callback_query
        if not query:
            return

        await query.answer()

        callback_data = query.data
        user = query.from_user

        # è·¯ç”±åˆ°å¯¹åº”çš„å¤„ç†å‡½æ•°
        handlers = {
            # åŠ¨æ€ç”Ÿæˆç¬”æ•°å¥—é¤è´­ä¹°å›è°ƒ
            **{f'buy_{count}_bishu': lambda q, u, c=count: self._callback_buy_bishu(q, u, c)
               for count in BISHA_CONFIG['available_packages']},

            # å…¶ä»–åŠŸèƒ½å›è°ƒ
            'check_bishu_status': self._callback_check_bishu_status,
            'contact_admin': self._callback_contact_admin,
            'back_to_main': self._callback_back_to_main,

            # å…¼å®¹æ—§çš„å›è°ƒ
            'energy_rent': self._callback_energy_rent,
            'bishu_package': self._callback_bishu_package,
            'my_status': self._callback_my_status,
            'manual_buy': self._callback_manual_buy,
            'cancel': self._callback_cancel,
            'refresh_status': self._callback_refresh_status,
            'admin_stats': self._callback_admin_stats,
            'admin_config': self._callback_admin_config,
            'admin_trades': self._callback_admin_trades,
            'admin_errors': self._callback_admin_errors,
        }

        handler = handlers.get(callback_data)
        if handler:
            await handler(query, user)
        else:
            await query.edit_message_text("âŒ æœªçŸ¥æ“ä½œ")

    # ===== å†…è”èœå•å›è°ƒå¤„ç†å‡½æ•° =====

    async def _callback_energy_rent_manual(self, query, user):
        """èƒ½é‡é—ªç§Ÿ - è‡ªåŠ©è´­ä¹°å›è°ƒ"""
        await self._callback_energy_rent(query, user)

    async def _callback_energy_rent_bishu(self, query, user):
        """èƒ½é‡é—ªç§Ÿ - ç¬”æ•°å¥—é¤å›è°ƒ"""
        await self._callback_setup_bishu(query, user)

    async def _callback_check_bishu_status(self, query, user):
        """æŸ¥çœ‹ç¬”æ•°å¥—é¤çŠ¶æ€å›è°ƒ"""
        await self._callback_my_status(query, user)

    async def _callback_buy_bishu(self, query, user, bishu_count):
        """è´­ä¹°æŒ‡å®šæ•°é‡ç¬”æ•°çš„å›è°ƒ"""
        price_per_bishu = BISHA_CONFIG['price_per_bishu']
        total_price = bishu_count * price_per_bishu

        text = (
            f"ğŸ’° <b>è´­ä¹° {bishu_count} ç¬”å¥—é¤</b>\n\n"
            f"ğŸ“Š ç¬”æ•°ï¼š{bishu_count} ç¬”\n"
            f"ğŸ’µ å•ä»·ï¼š{price_per_bishu} TRX/ç¬”\n"
            f"ğŸ’° æ€»ä»·ï¼š<b>{total_price} TRX</b>\n\n"
            "è¯·å‘ä»¥ä¸‹åœ°å€è½¬è´¦å¯¹åº” TRXï¼š\n\n"
            f"<code>{BISHA_CONFIG['receive_wallet']}</code>\n\n"
            "è½¬è´¦åç³»ç»Ÿä¼šè‡ªåŠ¨å¤„ç†å¹¶å‘é€èƒ½é‡åˆ°æ‚¨çš„åœ°å€ã€‚"
        )

        keyboard = [
            [InlineKeyboardButton("âŒ å–æ¶ˆ", callback_data="cancel")]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _callback_check_bishu_status(self, query, user):
        """æŸ¥çœ‹ç¬”æ•°çŠ¶æ€å›è°ƒ"""
        await self._callback_my_status(query, user)

    async def _callback_contact_admin(self, query, user):
        """è”ç³»å®¢æœå›è°ƒ"""
        text = (
            "ğŸ‘¨â€ğŸ’¼ <b>è”ç³»å®¢æœ</b>\n\n"
            "å¦‚éœ€å¸®åŠ©ï¼Œè¯·è”ç³»ç®¡ç†å‘˜ï¼š\n"
            "@admin\n\n"
            "æˆ–è¿”å›ä¸»èœå•ç»§ç»­ä½¿ç”¨"
        )

        keyboard = [
            [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back_to_main")]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _callback_back_to_main(self, query, user):
        """è¿”å›ä¸»èœå•å›è°ƒ"""
        welcome_text = (
            f"ğŸ‰ <b>æ‚¨å¥½ï¼Œè¶…çº§</b> ğŸ‰\n\n"
            f"ğŸªª <b>æ‚¨çš„IDï¼š{user.id}</b>\n\n"
            f"ğŸ‘ <b>æ¬¢è¿ä½¿ç”¨ ã€æ³¢åœºèƒ½é‡ç§Ÿèµã€‘</b>\n\n"
            f"<b>è¯·é€‰æ‹©ä»¥ä¸‹æœåŠ¡ï¼š</b>"
        )

        # è¿”å›ä¸€çº§é”®ç›˜èœå•
        keyboard = [
            [
                KeyboardButton("ğŸ”‹ èƒ½é‡é—ªç§Ÿ"),
                KeyboardButton("ğŸ“ ç¬”æ•°å¥—é¤")
            ],
            [
                KeyboardButton("ğŸ“Š æˆ‘çš„çŠ¶æ€"),
                KeyboardButton("ğŸ‘¨â€ğŸ’¼ è”ç³»å®¢æœ")
            ]
        ]

        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        await query.message.reply_text(
            welcome_text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    # ===== ä¸€çº§èœå•å¤„ç†å‡½æ•°ï¼ˆæ˜¾ç¤ºå†…è”èœå•ï¼‰=====

    async def _show_energy_rent_inline_menu(self, update, user):
        """æ˜¾ç¤ºèƒ½é‡é—ªç§Ÿå†…è”èœå•"""
        config = ENERGY_RENT_CONFIG
        prices = config['prices']

        text = (
            "ğŸ’¹ <b>å½“å‰èƒ½é‡ä»·æ ¼:</b>\n\n"
            f"å¯¹æ–¹æœ‰U   {prices['with_u']['trx']} TRX = {prices['with_u']['energy']:,}\n"
            f"å¯¹æ–¹æ— U   {prices['without_u']['trx']} TRX = {prices['without_u']['energy']:,}\n\n"
            f"æœ€é«˜å•ç¬”æ”¯æŒ {config['max_single_trx']} TRXï¼Œå¯æ”¶åˆ° {config['max_energy']:,} èƒ½é‡ã€‚\n\n"
            f"âš¡ ç§Ÿèµæ—¶é•¿é»˜è®¤ {config['rent_duration_hours']} å°æ—¶\n\n"
            "ğŸ’° è¯·å‘æ­¤åœ°å€è½¬è´¦å¯¹åº” TRXï¼Œæœºå™¨äººä¼šç«‹å³å‘é€ç›¸åº”èƒ½é‡åˆ°ä½ è´¦æˆ·ã€‚\n\n"
            "ğŸ‘‡ ç‚¹å‡»ä¸‹æ–¹åœ°å€å¯å¤åˆ¶\n\n"
            f"<code>{config['receive_wallet']}</code>"
        )

        keyboard = [
            [InlineKeyboardButton("âŒ å–æ¶ˆ", callback_data="cancel")]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _show_bishu_package_inline_menu(self, update, user):
        """æ˜¾ç¤ºç¬”æ•°å¥—é¤å†…è”èœå•"""
        text = (
            f"ğŸ”¥ <b>ç¬”æ•°å¥—é¤</b>\n\n"
            "ğŸ‘ æ¬¢è¿ä½¿ç”¨ã€ç¬”æ•°å¥—é¤ã€‘\n\n"
            f"ğŸ”¥ æŒ‰ç¬”æ•°ä¸‹å•ï¼Œæ²¡æœ‰æ—¶é•¿é™åˆ¶ï¼Œä¸‹å•æˆåŠŸåï¼Œå°†ç«‹åˆ»å‘é€{BISHA_CONFIG['energy_per_bishu']}èƒ½é‡åˆ°æ¥æ”¶åœ°å€ï¼Œæ¥æ”¶åœ°å€æ¯æ¬¡USDTè½¬è´¦åè®¡1ç¬”è´¹ç”¨ï¼Œä¸”èƒ½é‡å°†åœ¨{BISHA_CONFIG['energy_recovery_time']}ç§’å†…å†æ¬¡è¡¥å……è‡³{BISHA_CONFIG['energy_per_bishu']}ã€‚\n\n"
            f"â¤ï¸ å½“åœ°å€ä½™é¢å°‘äº{BISHA_CONFIG['auto_gift_trx_threshold']}TRXä¸”å¸¦å®½ä¸è¶³{BISHA_CONFIG['auto_gift_bandwidth_threshold']}å°†è‡ªåŠ¨èµ é€{BISHA_CONFIG['auto_gift_amount']}TRXï¼Œè®©æ‚¨ä¸æ»‘äº«å—USDTè½¬è´¦ã€‚\n\n"
            f"âš ï¸ {BISHA_CONFIG['deduct_after_hours']}å°æ—¶å†…æ²¡æœ‰è½¬è´¦ä¹Ÿå°†æ‰£å‡1ç¬”ã€‚è¿ç»­{BISHA_CONFIG['pause_after_hours']}å°æ—¶æ²¡æœ‰è½¬è´¦è‡ªåŠ¨æš‚åœï¼Œæ‚¨å¯åœ¨æœºå™¨äºº[æŸ¥è¯¢ç¬”æ•°]åæ‰‹åŠ¨å¼€å¯ã€‚\n\n"
            f"ğŸ‘‡ çœŸç¬”æ•°ï¼Œå•ç¬”ä»…éœ€ {BISHA_CONFIG['price_per_bishu']} TRXï¼Œè¯·æ ¹æ®ä¸ªäººéœ€æ±‚ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ä¸‹å•ã€‚"
        )

        # åŠ¨æ€ç”ŸæˆæŒ‰é’®
        packages = BISHA_CONFIG['available_packages']
        keyboard = []

        # åˆ†è¡Œæ˜¾ç¤ºï¼Œæ¯è¡Œ4ä¸ªæŒ‰é’®
        for i in range(0, len(packages), 4):
            row = []
            for j in range(4):
                if i + j < len(packages):
                    count = packages[i + j]
                    row.append(InlineKeyboardButton(f"{count}ç¬”", callback_data=f"buy_{count}_bishu"))
            if row:
                keyboard.append(row)

        # æ·»åŠ æ“ä½œæŒ‰é’®
        keyboard.append([
            InlineKeyboardButton("ğŸ”„ æŸ¥è¯¢ç¬”æ•°", callback_data="check_bishu_status"),
            InlineKeyboardButton("ğŸ‘¨â€ğŸ’¼ è”ç³»å®¢æœ", callback_data="contact_admin"),
            InlineKeyboardButton("âŒ å–æ¶ˆ", callback_data="cancel")
        ])

        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _show_my_status_inline_menu(self, update, user):
        """æ˜¾ç¤ºæˆ‘çš„çŠ¶æ€ - ç›´æ¥æ˜¾ç¤ºå½“å‰ç”¨æˆ·çŠ¶æ€"""
        await self._handle_status_via_message(update, user)

    async def _show_contact_admin_inline_menu(self, update, user):
        """æ˜¾ç¤ºè”ç³»å®¢æœå†…è”èœå•"""
        cs_config = BISHA_CONFIG['customer_service']
        text = (
            "ğŸ‘¨â€ğŸ’¼ <b>è”ç³»å®¢æœ</b>\n\n"
            f"å¦‚éœ€å¸®åŠ©ï¼Œè¯·è”ç³»ç®¡ç†å‘˜ï¼š\n"
            f"{cs_config['admin_username']}\n\n"
            f"å·¥ä½œæ—¶é—´ï¼š{cs_config['work_hours']}\n"
            f"æˆ‘ä»¬ä¼šåœ¨{cs_config['response_time']}å›å¤æ‚¨çš„é—®é¢˜"
        )

        keyboard = [
            [InlineKeyboardButton("ğŸ’¬ å‘é€æ¶ˆæ¯", url=f"https://t.me/{cs_config['admin_username'][1:]}")],
            [InlineKeyboardButton("âŒ å…³é—­", callback_data="cancel")]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(
            text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    # ===== äºŒçº§èœå•å¤„ç†å‡½æ•° =====

    async def _handle_energy_rent_menu(self, update, user):
        """å¤„ç†èƒ½é‡é—ªç§Ÿèœå•"""
        text = (
            "ğŸ”‹ <b>èƒ½é‡é—ªç§ŸæœåŠ¡</b>\n\n"
            "å°†TRXè½¬è´¦åˆ°ä»¥ä¸‹é’±åŒ…åœ°å€ï¼š\n\n"
            "<code>TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t</code>\n\n"
            "æ”¯æŒçš„TRXæ•°é‡ï¼š\n"
            "â€¢ 50 TRX = 32000èƒ½é‡\n"
            "â€¢ 100 TRX = 65000èƒ½é‡\n\n"
            "è½¬è´¦åèƒ½é‡ä¼šåœ¨1-3åˆ†é’Ÿå†…åˆ°è´¦\n"
            "âš ï¸ è¯·å‹¿å‘é€å…¶ä»–ä»£å¸ï¼Œåªå‘é€TRX"
        )

        keyboard = [
            [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back_to_main")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await update.message.reply_text(
            text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _handle_bishu_package_menu(self, update, user):
        """å¤„ç†ç¬”æ•°å¥—é¤èœå•"""
        await self._callback_setup_bishu_via_message(update, user)

    async def _handle_my_status_menu(self, update, user):
        """å¤„ç†æˆ‘çš„çŠ¶æ€èœå•"""
        await self._handle_status_via_message(update, user)

    async def _handle_help_menu(self, update, user):
        """å¤„ç†å¸®åŠ©èœå•"""
        await self._handle_help_via_message(update, user)

    async def _handle_back_to_main_menu(self, update, user):
        """å¤„ç†è¿”å›ä¸»èœå•"""
        welcome_text = (
            f"ğŸ‰ <b>æ‚¨å¥½ï¼Œè¶…çº§</b> ğŸ‰\n\n"
            f"ğŸªª <b>æ‚¨çš„IDï¼š{user.id}</b>\n\n"
            f"ğŸ‘ <b>æ¬¢è¿ä½¿ç”¨ ã€æ³¢åœºèƒ½é‡ç§Ÿèµã€‘</b>\n\n"
            f"<b>è¯·é€‰æ‹©ä»¥ä¸‹æœåŠ¡ï¼š</b>"
        )

        keyboard = [
            [
                KeyboardButton("ğŸ”‹ èƒ½é‡é—ªç§Ÿ"),
                KeyboardButton("ğŸ“ ç¬”æ•°å¥—é¤")
            ],
            [
                KeyboardButton("ğŸ“Š æˆ‘çš„çŠ¶æ€"),
                KeyboardButton("ğŸ‘¨â€ğŸ’¼ è”ç³»å®¢æœ")
            ]
        ]

        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
        await update.message.reply_text(
            welcome_text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _handle_cancel_setup(self, update, user):
        """å¤„ç†å–æ¶ˆè®¾ç½®"""
        # æ¸…é™¤ç”¨æˆ·çŠ¶æ€
        if user.id in self.user_states:
            del self.user_states[user.id]

        text = "âŒ æ“ä½œå·²å–æ¶ˆ\n\nè¿”å›ä¸»èœå•"
        await self._handle_back_to_main_menu(update, user)

    async def _handle_contact_admin(self, update, user):
        """å¤„ç†è”ç³»å®¢æœ"""
        text = "ğŸ‘¨â€ğŸ’¼ <b>è”ç³»å®¢æœ</b>\n\nå¦‚éœ€å¸®åŠ©ï¼Œè¯·è”ç³»ç®¡ç†å‘˜ï¼š\n@admin\n\næˆ–å‘é€ /start è¿”å›ä¸»èœå•"
        await update.message.reply_text(text, parse_mode='HTML')

    async def _handle_secondary_menu_actions(self, update, user, text):
        """å¤„ç†äºŒçº§èœå•åŠ¨ä½œ"""
        # å¤„ç†å–æ¶ˆè®¾ç½®ç­‰æ“ä½œ
        if text == 'âŒ å–æ¶ˆè®¾ç½®':
            await self._handle_cancel_setup(update, user)
        elif text == 'âŒ å–æ¶ˆæŸ¥è¯¢':
            await self._handle_cancel_wallet_status_query(update, user)
        else:
            # æ£€æŸ¥ç”¨æˆ·çŠ¶æ€
            user_state = self.user_states.get(user.id)
            if user_state:
                state = user_state.get('state')
                action = user_state.get('action')

                if state == 'waiting_wallet_address':
                    await self._handle_wallet_address_input(update, user, text, action)
                elif state == 'waiting_wallet_status':
                    await self._handle_wallet_status_input(update, user, text)
            else:
                # æœªçŸ¥æ¶ˆæ¯ï¼Œå‘é€å¸®åŠ©ä¿¡æ¯
                await update.message.reply_text(
                    "è¯·ä½¿ç”¨é”®ç›˜èœå•é€‰æ‹©åŠŸèƒ½ï¼Œæˆ–å‘é€ /start å¼€å§‹ä½¿ç”¨"
                )

    # ===== å›è°ƒå¤„ç†å‡½æ•° =====

    async def _callback_energy_rent(self, query, user):
        """èƒ½é‡é—ªç§Ÿå›è°ƒ"""
        text = (
            "ğŸ”‹ <b>èƒ½é‡é—ªç§ŸæœåŠ¡</b>\n\n"
            "å°†TRXè½¬è´¦åˆ°ä»¥ä¸‹é’±åŒ…åœ°å€ï¼š\n\n"
            "<code>TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t</code>\n\n"
            "æ”¯æŒçš„TRXæ•°é‡ï¼š\n"
            "â€¢ 50 TRX = 32000èƒ½é‡\n"
            "â€¢ 100 TRX = 65000èƒ½é‡\n\n"
            "è½¬è´¦åèƒ½é‡ä¼šåœ¨1-3åˆ†é’Ÿå†…åˆ°è´¦\n"
            "âš ï¸ è¯·å‹¿å‘é€å…¶ä»–ä»£å¸ï¼Œåªå‘é€TRX"
        )

        keyboard = [
            [InlineKeyboardButton("ğŸ“‹ å¤åˆ¶åœ°å€", callback_data="copy_address")],
            [InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="back_to_main")]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _callback_ai_trusteeship(self, query, user):
        """æ™ºèƒ½æ‰˜ç®¡å›è°ƒ"""
        await self._callback_setup_trusteeship(query, user)

    async def _callback_bishu_package(self, query, user):
        """ç¬”æ•°å¥—é¤å›è°ƒ"""
        await self._callback_setup_bishu(query, user)

    async def _callback_trx_exchange(self, query, user):
        """TRXé—ªå…‘å›è°ƒ"""
        text = (
            "ğŸ’° <b>TRXé—ªå…‘æœåŠ¡</b>\n\n"
            "æš‚æ—¶ä¸å¯ç”¨\n\n"
            "å¦‚éœ€å…‘æ¢æœåŠ¡ï¼Œè¯·è”ç³»å®¢æœ"
        )

        keyboard = [
            [InlineKeyboardButton("ğŸ‘¨â€ğŸ’¼ è”ç³»å®¢æœ", url="https://t.me/admin")],
            [InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="back_to_main")]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _callback_my_status(self, query, user):
        """æˆ‘çš„çŠ¶æ€å›è°ƒ"""
        await self._handle_status_via_query(query, user)

    async def _callback_help(self, query, user):
        """å¸®åŠ©å›è°ƒ"""
        await self._handle_help_via_query(query, user)

    async def _callback_manual_buy(self, query, user):
        """æ‰‹åŠ¨è´­ä¹°å›è°ƒ"""
        await self._callback_energy_rent(query, user)

    async def _callback_setup_bishu(self, query, user):
        """è®¾ç½®ç¬”æ•°å¥—é¤å›è°ƒ"""
        # è®¾ç½®ç”¨æˆ·çŠ¶æ€
        self.user_states[user.id] = {
            'state': 'waiting_wallet_address',
            'action': 'setup_bishu'
        }

        text = (
            "ğŸ“ <b>è®¾ç½®ç¬”æ•°å¥—é¤</b>\n\n"
            "è¯·å›å¤æ‚¨çš„TRONé’±åŒ…åœ°å€ï¼š\n\n"
            "<b>ç¬”æ•°å¥—é¤è¯´æ˜ï¼š</b>\n"
            "â€¢ USDTè´­ä¹°å›ºå®šæ¬¡æ•°çš„èƒ½é‡ä½¿ç”¨æƒ\n"
            "â€¢ æ¯æ¬¡ä½¿ç”¨æ¶ˆè€—1ä¸ªç¬”æ•°\n"
            "â€¢ èƒ½é‡è‡ªåŠ¨è¡¥å……ï¼Œæ— éœ€ç­‰å¾…\n"
            "â€¢ æ›´é€‚åˆå¶å°”ä½¿ç”¨çš„ç”¨æˆ·\n\n"
            "<b>ä»·æ ¼ï¼š</b>\n"
            "â€¢ 1 USDT = çº¦50ä¸ªç¬”æ•°\n"
            "â€¢ èƒ½é‡æ•°é‡ï¼š50000æ¯æ¬¡\n\n"
            "<b>è´­ä¹°æ–¹å¼ï¼š</b>\n"
            "å‘ä»¥ä¸‹åœ°å€è½¬è´¦USDTï¼š\n"
            "<code>TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t</code>"
        )

        keyboard = [
            [InlineKeyboardButton("âŒ å–æ¶ˆè®¾ç½®", callback_data="cancel")]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _callback_setup_bishu_via_message(self, update, user):
        """é€šè¿‡æ¶ˆæ¯è®¾ç½®ç¬”æ•°å¥—é¤"""
        # è®¾ç½®ç”¨æˆ·çŠ¶æ€
        self.user_states[user.id] = {
            'state': 'waiting_wallet_address',
            'action': 'setup_bishu'
        }

        text = (
            "ğŸ“ <b>è®¾ç½®ç¬”æ•°å¥—é¤</b>\n\n"
            "è¯·å›å¤æ‚¨çš„TRONé’±åŒ…åœ°å€ï¼š\n\n"
            "<b>ç¬”æ•°å¥—é¤è¯´æ˜ï¼š</b>\n"
            "â€¢ USDTè´­ä¹°å›ºå®šæ¬¡æ•°çš„èƒ½é‡ä½¿ç”¨æƒ\n"
            "â€¢ æ¯æ¬¡ä½¿ç”¨æ¶ˆè€—1ä¸ªç¬”æ•°\n"
            "â€¢ èƒ½é‡è‡ªåŠ¨è¡¥å……ï¼Œæ— éœ€ç­‰å¾…\n"
            "â€¢ æ›´é€‚åˆå¶å°”ä½¿ç”¨çš„ç”¨æˆ·\n\n"
            "<b>ä»·æ ¼ï¼š</b>\n"
            "â€¢ 1 USDT = çº¦50ä¸ªç¬”æ•°\n"
            "â€¢ èƒ½é‡æ•°é‡ï¼š50000æ¯æ¬¡\n\n"
            "<b>è´­ä¹°æ–¹å¼ï¼š</b>\n"
            "å‘ä»¥ä¸‹åœ°å€è½¬è´¦USDTï¼š\n"
            "<code>TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t</code>"
        )

        keyboard = [
            [InlineKeyboardButton("âŒ å–æ¶ˆè®¾ç½®", callback_data="cancel")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await update.message.reply_text(
            text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _callback_cancel(self, query, user):
        """å–æ¶ˆå›è°ƒ"""
        # æ¸…é™¤ç”¨æˆ·çŠ¶æ€
        if user.id in self.user_states:
            del self.user_states[user.id]

        text = "âŒ æ“ä½œå·²å–æ¶ˆ\n\nå‘é€ /start é‡æ–°å¼€å§‹"
        await query.edit_message_text(text)

    async def _callback_refresh_status(self, query, user):
        """åˆ·æ–°çŠ¶æ€å›è°ƒ"""
        await self._handle_status_via_query(query, user)

    async def _callback_admin_stats(self, query, user):
        """ç®¡ç†å‘˜ç»Ÿè®¡å›è°ƒ"""
        text = "ğŸ“ˆ <b>ç³»ç»Ÿç»Ÿè®¡</b>\n\næ­£åœ¨è·å–ç»Ÿè®¡æ•°æ®..."
        await query.edit_message_text(text, parse_mode='HTML')

        # è¿™é‡Œåº”è¯¥å®ç°çœŸæ­£çš„ç»Ÿè®¡é€»è¾‘
        stats_text = (
            "ğŸ“ˆ <b>ç³»ç»Ÿç»Ÿè®¡</b>\n\n"
            "<b>ä»Šæ—¥æ•°æ®ï¼š</b>\n"
            f"â€¢ äº¤æ˜“å¤„ç†ï¼š{0} ç¬”\n"
            f"â€¢ èƒ½é‡ç§Ÿèµï¼š{0} æ¬¡\n"
            f"â€¢ æ´»è·ƒç”¨æˆ·ï¼š{0} ä¸ª\n"
            f"â€¢ æ€»æ”¶å…¥ï¼š{0} TRX\n\n"
            "<b>ç³»ç»ŸçŠ¶æ€ï¼š</b>\n"
            "â€¢ æ•°æ®åº“ï¼šæ­£å¸¸\n"
            "â€¢ APIæœåŠ¡ï¼šæ­£å¸¸\n"
            "â€¢ æœºå™¨äººï¼šè¿è¡Œä¸­"
        )

        keyboard = [
            [InlineKeyboardButton("ğŸ”™ è¿”å›", callback_data="back_to_admin")]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            stats_text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _callback_admin_config(self, query, user):
        """ç®¡ç†å‘˜é…ç½®å›è°ƒ"""
        text = "ğŸ”§ <b>é…ç½®ç®¡ç†</b>\n\nåŠŸèƒ½å¼€å‘ä¸­..."
        await query.edit_message_text(text, parse_mode='HTML')

    async def _callback_admin_trades(self, query, user):
        """ç®¡ç†å‘˜äº¤æ˜“è®°å½•å›è°ƒ"""
        text = "ğŸ“Š <b>äº¤æ˜“è®°å½•</b>\n\nåŠŸèƒ½å¼€å‘ä¸­..."
        await query.edit_message_text(text, parse_mode='HTML')

    async def _callback_admin_errors(self, query, user):
        """ç®¡ç†å‘˜å¼‚å¸¸å¤„ç†å›è°ƒ"""
        text = "ğŸš¨ <b>å¼‚å¸¸å¤„ç†</b>\n\nåŠŸèƒ½å¼€å‘ä¸­..."
        await query.edit_message_text(text, parse_mode='HTML')

    # ===== æ–‡æœ¬æ¶ˆæ¯å¤„ç†å™¨ =====

    async def _handle_text_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """å¤„ç†æ–‡æœ¬æ¶ˆæ¯"""
        user = update.effective_user
        if not user:
            return

        text = update.message.text.strip()

        # æ£€æŸ¥ç”¨æˆ·çŠ¶æ€
        user_state = self.user_states.get(user.id)
        if user_state:
            state = user_state.get('state')
            action = user_state.get('action')

            if state == 'waiting_wallet_address':
                await self._handle_wallet_address_input(update, user, text, action)
            return

        # å¤„ç†é”®ç›˜èœå•ç‚¹å‡»ï¼ˆä¸€çº§èœå•ï¼‰
        menu_handlers = {
            'ğŸ”‹ èƒ½é‡é—ªç§Ÿ': self._show_energy_rent_inline_menu,
            'ğŸ“ ç¬”æ•°å¥—é¤': self._show_bishu_package_inline_menu,
            'ğŸ“Š æˆ‘çš„çŠ¶æ€': self._show_my_status_inline_menu,
            'ğŸ‘¨â€ğŸ’¼ å®¢æœ': self._show_contact_admin_inline_menu,
        }

        handler = menu_handlers.get(text)
        if handler:
            await handler(update, user)
        else:
            # å¤„ç†äºŒçº§èœå•æˆ–å…¶ä»–æ“ä½œ
            await self._handle_secondary_menu_actions(update, user, text)

    async def _handle_wallet_status_input(self, update, user, wallet_address):
        """å¤„ç†é’±åŒ…çŠ¶æ€æŸ¥è¯¢è¾“å…¥"""
        # éªŒè¯é’±åŒ…åœ°å€æ ¼å¼
        if not self._is_valid_tron_address(wallet_address):
            await update.message.reply_text(
                "âŒ æ— æ•ˆçš„TRONé’±åŒ…åœ°å€æ ¼å¼\n\n"
                "è¯·æ£€æŸ¥åœ°å€æ˜¯å¦æ­£ç¡®\n"
                "TRONåœ°å€ä»¥Tå¼€å¤´ï¼Œå…±34ä½å­—ç¬¦"
            )
            return

        # æŸ¥è¯¢é’±åŒ…çŠ¶æ€
        trusteeship_model = EnergyAiTrusteeshipModel()
        bishu_model = EnergyAiBishuModel()

        trusteeship_data = trusteeship_model.get_by_wallet_addr(wallet_address)
        bishu_data = bishu_model.get_by_wallet_addr(wallet_address)

        status_text = f"ğŸ“Š <b>é’±åŒ…çŠ¶æ€æŸ¥è¯¢</b>\n\n"
        status_text += f"ğŸ  <b>é’±åŒ…åœ°å€ï¼š</b>\n<code>{wallet_address}</code>\n\n"

        has_service = False

        if trusteeship_data:
            has_service = True
            status_text += (
                f"ğŸ¤– <b>æ™ºèƒ½æ‰˜ç®¡æœåŠ¡</b>\n"
                f"â€¢ çŠ¶æ€ï¼š{'è¿è¡Œä¸­' if trusteeship_data.get('is_buy') == 'N' else 'è´­ä¹°ä¸­'}\n"
                f"â€¢ å½“å‰èƒ½é‡ï¼š{trusteeship_data.get('current_energy_quantity', 0)}\n"
                f"â€¢ å·²è´­ä¹°æ¬¡æ•°ï¼š{trusteeship_data.get('total_buy_quantity', 0)}\n"
                f"â€¢ æ³¨å†Œæ—¶é—´ï¼š{trusteeship_data.get('create_time', 'æœªçŸ¥')}\n\n"
            )

        if bishu_data:
            has_service = True
            status_text += (
                f"ğŸ“ <b>ç¬”æ•°å¥—é¤æœåŠ¡</b>\n"
                f"â€¢ çŠ¶æ€ï¼š{'æ­£å¸¸' if bishu_data.get('is_buy') == 'N' else 'è´­ä¹°ä¸­'}\n"
                f"â€¢ å½“å‰èƒ½é‡ï¼š{bishu_data.get('current_energy_quantity', 0)}\n"
                f"â€¢ å·²ä½¿ç”¨ç¬”æ•°ï¼š{bishu_data.get('total_buy_quantity', 0)}\n"
                f"â€¢ å‰©ä½™ç¬”æ•°ï¼š{bishu_data.get('max_buy_quantity', 0) - bishu_data.get('total_buy_quantity', 0)}\n"
                f"â€¢ æ³¨å†Œæ—¶é—´ï¼š{bishu_data.get('create_time', 'æœªçŸ¥')}\n\n"
            )

        if not has_service:
            status_text += "âŒ æ­¤é’±åŒ…åœ°å€æœªæ³¨å†Œä»»ä½•æœåŠ¡\n\nå¦‚éœ€ä½¿ç”¨æœåŠ¡ï¼Œè¯·å…ˆè¿›è¡Œè®¾ç½®"

        # æ¸…é™¤ç”¨æˆ·çŠ¶æ€
        if user.id in self.user_states:
            del self.user_states[user.id]

        keyboard = [
            [
                KeyboardButton("ğŸ”‹ èƒ½é‡é—ªç§Ÿ"),
                KeyboardButton("ğŸ“ ç¬”æ•°å¥—é¤")
            ],
            [
                KeyboardButton("ğŸ“Š æˆ‘çš„çŠ¶æ€"),
                KeyboardButton("ğŸ‘¨â€ğŸ’¼ è”ç³»å®¢æœ")
            ]
        ]
        reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

        await update.message.reply_text(
            status_text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _handle_cancel_wallet_status_query(self, update, user):
        """å–æ¶ˆé’±åŒ…çŠ¶æ€æŸ¥è¯¢"""
        # æ¸…é™¤ç”¨æˆ·çŠ¶æ€
        if user.id in self.user_states:
            del self.user_states[user.id]

        text = "âŒ å·²å–æ¶ˆæŸ¥è¯¢\n\nè¿”å›ä¸»èœå•"
        await self._handle_back_to_main_menu(update, user)

    async def _handle_wallet_address_input(self, update, user, wallet_address, action):
        """å¤„ç†é’±åŒ…åœ°å€è¾“å…¥"""
        # éªŒè¯é’±åŒ…åœ°å€æ ¼å¼
        if not self._is_valid_tron_address(wallet_address):
            await update.message.reply_text(
                "âŒ æ— æ•ˆçš„TRONé’±åŒ…åœ°å€æ ¼å¼\n\n"
                "è¯·æ£€æŸ¥åœ°å€æ˜¯å¦æ­£ç¡®\n"
                "TRONåœ°å€ä»¥Tå¼€å¤´ï¼Œå…±34ä½å­—ç¬¦"
            )
            return

        # æ ¹æ®ä¸åŒçš„actionå¤„ç†
        if action == 'setup_trusteeship':
            await self._setup_trusteeship(update, user, wallet_address)
        elif action == 'setup_bishu':
            await self._setup_bishu(update, user, wallet_address)
        elif action == 'buy_energy':
            await self._process_energy_purchase(update, user, wallet_address)
        else:
            await update.message.reply_text("âŒ æœªçŸ¥æ“ä½œç±»å‹")

        # æ¸…é™¤ç”¨æˆ·çŠ¶æ€
        if user.id in self.user_states:
            del self.user_states[user.id]

    async def _setup_bishu(self, update, user, wallet_address):
        """è®¾ç½®ç¬”æ•°å¥—é¤"""
        try:
            # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
            bishu_model = EnergyAiBishuModel()
            existing = bishu_model.get_by_wallet_addr(wallet_address)

            if existing:
                await update.message.reply_text(
                    "âš ï¸ æ­¤é’±åŒ…åœ°å€å·²è®¾ç½®ç¬”æ•°å¥—é¤\n\n"
                    "è¯·ä½¿ç”¨å…¶ä»–åœ°å€æˆ–è”ç³»å®¢æœ"
                )
                return

            # åˆ›å»ºç¬”æ•°å¥—é¤è®°å½•
            insert_data = {
                'bot_rid': 1,
                'wallet_addr': wallet_address,
                'tg_uid': str(user.id),
                'per_bishu_energy_quantity': 50000,
                'max_buy_quantity': 1000,
                'is_buy': 'N',
                'status': 0,
                'current_energy_quantity': 0,
                'total_buy_quantity': 0,
                'total_buy_usdt': 0,
                'is_notice': 'Y',
                'is_notice_admin': 'N',
                'create_time': EnergyUtils.now_date()
            }

            bishu_model.insert(insert_data)

            success_text = (
                "âœ… <b>ç¬”æ•°å¥—é¤è®¾ç½®æˆåŠŸï¼</b>\n\n"
                f"é’±åŒ…åœ°å€ï¼š{EnergyUtils.format_address(wallet_address)}\n\n"
                "<b>ç°åœ¨å¯ä»¥è´­ä¹°ç¬”æ•°ï¼š</b>\n"
                "â€¢ å‘æŒ‡å®šåœ°å€è½¬è´¦USDT\n"
                "â€¢ 1 USDT â‰ˆ 50ä¸ªç¬”æ•°\n"
                "â€¢ æ¯ä¸ªç¬”æ•° = 50000èƒ½é‡\n\n"
                "è´­ä¹°åœ°å€ï¼š\n"
                "<code>TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t</code>\n\n"
                "å‘é€ /status æŸ¥çœ‹çŠ¶æ€"
            )

            await update.message.reply_text(
                success_text,
                parse_mode='HTML'
            )

        except Exception as e:
            self.logger.error(f"è®¾ç½®ç¬”æ•°å¥—é¤å¤±è´¥: {str(e)}")
            await update.message.reply_text("âŒ è®¾ç½®å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•")

    async def _process_energy_purchase(self, update, user, wallet_address):
        """å¤„ç†èƒ½é‡è´­ä¹°"""
        await update.message.reply_text(
            f"ğŸ”„ æ­£åœ¨å¤„ç†é’±åŒ… {EnergyUtils.format_address(wallet_address)} çš„èƒ½é‡è´­ä¹°...\n\n"
            "è¯·ç¨å€™..."
        )

        # è¿™é‡Œå¯ä»¥è°ƒç”¨å®é™…çš„è´­ä¹°é€»è¾‘
        # æš‚æ—¶è¿”å›æç¤ºä¿¡æ¯
        await update.message.reply_text(
            "âœ… èƒ½é‡è´­ä¹°è¯·æ±‚å·²æ¥æ”¶\n\n"
            "ç³»ç»Ÿæ­£åœ¨å¤„ç†æ‚¨çš„è¯·æ±‚ï¼Œè¯·ç­‰å¾…åˆ°è´¦é€šçŸ¥"
        )

    # ===== è¾…åŠ©æ–¹æ³• =====

    def _is_valid_tron_address(self, address: str) -> bool:
        """éªŒè¯TRONåœ°å€æ ¼å¼"""
        if not address or not isinstance(address, str):
            return False

        # TRONåœ°å€åŸºæœ¬æ ¼å¼æ£€æŸ¥
        return (
            address.startswith('T') and
            len(address) == 34 and
            address.isalnum()
        )

    async def _handle_status_via_query(self, query, user):
        """é€šè¿‡queryå¤„ç†çŠ¶æ€æŸ¥è¯¢"""
        # å¤ç”¨çŠ¶æ€å¤„ç†é€»è¾‘
        trusteeship_model = EnergyAiTrusteeshipModel()
        bishu_model = EnergyAiBishuModel()

        trusteeship_data = trusteeship_model.get_by_wallet_addr(f"user_{user.id}")
        bishu_data = bishu_model.get_by_wallet_addr(f"user_{user.id}")

        status_text = f"ğŸ“Š <b>{user.first_name} çš„è´¦æˆ·çŠ¶æ€</b>\n\n"

        if trusteeship_data:
            status_text += (
                f"ğŸ¤– <b>æ™ºèƒ½æ‰˜ç®¡</b>\n"
                f"çŠ¶æ€ï¼š{'è¿è¡Œä¸­' if trusteeship_data.get('is_buy') == 'N' else 'è´­ä¹°ä¸­'}\n"
                f"å½“å‰èƒ½é‡ï¼š{trusteeship_data.get('current_energy_quantity', 0)}\n"
                f"å·²è´­ä¹°ï¼š{trusteeship_data.get('total_buy_quantity', 0)} æ¬¡\n\n"
            )

        if bishu_data:
            status_text += (
                f"ğŸ“ <b>ç¬”æ•°å¥—é¤</b>\n"
                f"çŠ¶æ€ï¼š{'æ­£å¸¸' if bishu_data.get('is_buy') == 'N' else 'è´­ä¹°ä¸­'}\n"
                f"å½“å‰èƒ½é‡ï¼š{bishu_data.get('current_energy_quantity', 0)}\n"
                f"å·²è´­ä¹°ï¼š{bishu_data.get('total_buy_quantity', 0)} æ¬¡\n"
                f"USDTæ¶ˆè´¹ï¼š{bishu_data.get('total_buy_usdt', 0)}\n\n"
            )

        if not trusteeship_data and not bishu_data:
            status_text += "âŒ æ‚¨è¿˜æ²¡æœ‰è®¾ç½®ä»»ä½•æœåŠ¡\n\nå‘é€ /buyenergy å¼€å§‹ä½¿ç”¨"

        keyboard = [
            [InlineKeyboardButton("ğŸ”„ åˆ·æ–°", callback_data="refresh_status")]
        ]

        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(
            status_text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _handle_help_via_query(self, query, user):
        """é€šè¿‡queryå¤„ç†å¸®åŠ©"""
        help_text = (
            "ğŸ“š <b>èƒ½é‡ç§Ÿèµæœºå™¨äººä½¿ç”¨å¸®åŠ©</b>\n\n"
            "<b>åŸºç¡€å‘½ä»¤ï¼š</b>\n"
            "/start - å¼€å§‹ä½¿ç”¨æœºå™¨äºº\n"
            "/buyenergy - è´­ä¹°èƒ½é‡æœåŠ¡\n"
            "/status - æŸ¥çœ‹æˆ‘çš„çŠ¶æ€\n"
            "/help - æ˜¾ç¤ºæ­¤å¸®åŠ©\n\n"
            "<b>æœåŠ¡è¯´æ˜ï¼š</b>\n\n"
            "ğŸ”‹ <b>è‡ªåŠ©è´­ä¹°</b>\n"
            "å‘æŒ‡å®šé’±åŒ…è½¬è´¦TRXï¼Œè‡ªåŠ¨è´­ä¹°èƒ½é‡\n\n"
            "ğŸ¤– <b>æ™ºèƒ½æ‰˜ç®¡</b>\n"
            "è‡ªåŠ¨ç›‘æ§å’Œè¡¥å……èƒ½é‡ï¼Œæ— äººå€¼å®ˆ\n\n"
            "ğŸ“ <b>ç¬”æ•°å¥—é¤</b>\n"
            "USDTè´­ä¹°å›ºå®šæ¬¡æ•°ï¼Œæ›´çœé’±\n\n"
            "ğŸ’° <b>TRXé—ªå…‘</b>\n"
            "TRXä¸USDTå¿«é€Ÿå…‘æ¢"
        )

        await query.edit_message_text(
            help_text,
            parse_mode='HTML'
        )

    async def _handle_help_via_message(self, update, user):
        """é€šè¿‡æ¶ˆæ¯å¤„ç†å¸®åŠ©"""
        help_text = (
            "ğŸ“š <b>èƒ½é‡ç§Ÿèµæœºå™¨äººä½¿ç”¨å¸®åŠ©</b>\n\n"
            "<b>åŸºç¡€å‘½ä»¤ï¼š</b>\n"
            "/start - å¼€å§‹ä½¿ç”¨æœºå™¨äºº\n"
            "/buyenergy - è´­ä¹°èƒ½é‡æœåŠ¡\n"
            "/status - æŸ¥çœ‹æˆ‘çš„çŠ¶æ€\n"
            "/help - æ˜¾ç¤ºæ­¤å¸®åŠ©\n\n"
            "<b>æœåŠ¡è¯´æ˜ï¼š</b>\n\n"
            "ğŸ”‹ <b>è‡ªåŠ©è´­ä¹°</b>\n"
            "å‘æŒ‡å®šé’±åŒ…è½¬è´¦TRXï¼Œè‡ªåŠ¨è´­ä¹°èƒ½é‡\n\n"
            "ğŸ¤– <b>æ™ºèƒ½æ‰˜ç®¡</b>\n"
            "è‡ªåŠ¨ç›‘æ§å’Œè¡¥å……èƒ½é‡ï¼Œæ— äººå€¼å®ˆ\n\n"
            "ğŸ“ <b>ç¬”æ•°å¥—é¤</b>\n"
            "USDTè´­ä¹°å›ºå®šæ¬¡æ•°ï¼Œæ›´çœé’±\n\n"
            "ğŸ’° <b>TRXé—ªå…‘</b>\n"
            "TRXä¸USDTå¿«é€Ÿå…‘æ¢"
        )

        keyboard = [
            [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back_to_main")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await update.message.reply_text(
            help_text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _handle_status_via_message(self, update, user):
        """é€šè¿‡æ¶ˆæ¯å¤„ç†çŠ¶æ€æŸ¥è¯¢"""
        # æŸ¥è¯¢ç¬”æ•°å¥—é¤çŠ¶æ€
        bishu_model = EnergyAiBishuModel()
        bishu_data = bishu_model.get_by_wallet_addr(f"user_{user.id}")

        status_text = f"ğŸ“Š <b>{user.first_name} çš„è´¦æˆ·çŠ¶æ€</b>\n\n"

        if bishu_data:
            status_text += (
                f"ğŸ“ <b>ç¬”æ•°å¥—é¤</b>\n"
                f"çŠ¶æ€ï¼š{'æ­£å¸¸' if bishu_data.get('is_buy') == 'N' else 'è´­ä¹°ä¸­'}\n"
                f"å½“å‰èƒ½é‡ï¼š{bishu_data.get('current_energy_quantity', 0)}\n"
                f"å·²ä½¿ç”¨ç¬”æ•°ï¼š{bishu_data.get('total_buy_quantity', 0)}\n"
                f"å‰©ä½™ç¬”æ•°ï¼š{bishu_data.get('max_buy_quantity', 0) - bishu_data.get('total_buy_quantity', 0)}\n"
                f"USDTæ¶ˆè´¹ï¼š{bishu_data.get('total_buy_usdt', 0)}\n\n"
            )
        else:
            status_text += "âŒ æ‚¨è¿˜æ²¡æœ‰è´­ä¹°ä»»ä½•ç¬”æ•°å¥—é¤\n\nå‘é€ /start å¼€å§‹è´­ä¹°"

        keyboard = [
            [InlineKeyboardButton("ğŸ”™ è¿”å›ä¸»èœå•", callback_data="back_to_main")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await update.message.reply_text(
            status_text,
            reply_markup=reply_markup,
            parse_mode='HTML'
        )

    async def _handle_error(self, update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
        """å¤„ç†é”™è¯¯"""
        self.logger.error(f"Update {update} caused error {context.error}")
        # è¿™é‡Œå¯ä»¥å‘é€é”™è¯¯æŠ¥å‘Šç»™ç®¡ç†å‘˜
-e 

--- File: ./energy_rental_bot/main.py ---
#!/usr/bin/env python3
"""
èƒ½é‡ç§Ÿèµæœºå™¨äººä¸»å…¥å£æ–‡ä»¶
"""

import sys
import argparse
from pathlib import Path

# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°Pythonè·¯å¾„
BASE_DIR = Path(__file__).parent
sys.path.insert(0, str(BASE_DIR))

from utils.energy_utils import EnergyUtils
from controllers.energy_controller import TrongasIoController
from tasks.handle_energy_order_task import HandleEnergyOrderTask
from tasks.get_energy_wallet_trx_trade_task import GetEnergyWalletTrxTradeTask
from tasks.get_ai_trusteeship_wallet_resource_task import GetAiTrusteeshipWalletResourceTask
from tasks.handle_ai_energy_order_task import HandleAiEnergyOrderTask
from tasks.send_energy_tg_message_task import SendEnergyTgMessageTask


def main():
    """ä¸»å‡½æ•°"""
    # è®¾ç½®æ—¥å¿—
    EnergyUtils.setup_logging()

    parser = argparse.ArgumentParser(description='èƒ½é‡ç§Ÿèµæœºå™¨äºº')
    parser.add_argument('task', choices=[
        'HandleEnergyOrder',
        'GetEnergyWalletTrxTrade',
        'GetAiTrusteeshipWalletResource',
        'HandleAiEnergyOrder',
        'SendEnergyTgMessage',
        'notice'  # APIå›è°ƒå¤„ç†
    ], help='è¦æ‰§è¡Œçš„ä»»åŠ¡')
    parser.add_argument('--receive-address', help='æ¥æ”¶åœ°å€ (ç”¨äºnoticeä»»åŠ¡)')
    parser.add_argument('--residue', help='å‰©ä½™æ•°é‡ (ç”¨äºnoticeä»»åŠ¡)')

    args = parser.parse_args()

    try:
        if args.task == 'HandleEnergyOrder':
            task = HandleEnergyOrderTask()
            task.execute()
            print("èƒ½é‡è®¢å•å¤„ç†å®Œæˆ")

        elif args.task == 'GetEnergyWalletTrxTrade':
            task = GetEnergyWalletTrxTradeTask()
            task.execute()
            print("TRXäº¤æ˜“æ•°æ®è·å–å®Œæˆ")

        elif args.task == 'GetAiTrusteeshipWalletResource':
            task = GetAiTrusteeshipWalletResourceTask()
            task.execute()
            print("é’±åŒ…èµ„æºæ£€æŸ¥å®Œæˆ")

        elif args.task == 'HandleAiEnergyOrder':
            task = HandleAiEnergyOrderTask()
            task.execute()
            print("AIèƒ½é‡è®¢å•å¤„ç†å®Œæˆ")

        elif args.task == 'SendEnergyTgMessage':
            task = SendEnergyTgMessageTask()
            task.execute()
            print("æ¶ˆæ¯é€šçŸ¥å‘é€å®Œæˆ")

        elif args.task == 'notice':
            if not args.receive_address:
                print("é”™è¯¯: noticeä»»åŠ¡éœ€è¦ --receive-address å‚æ•°")
                sys.exit(1)

            controller = TrongasIoController()
            result = controller.notice({
                'receiveAddress': args.receive_address,
                'residue': args.residue or ''
            })
            print(f"APIå›è°ƒå¤„ç†ç»“æœ: {result}")

        else:
            print(f"æœªçŸ¥ä»»åŠ¡: {args.task}")
            sys.exit(1)

    except Exception as e:
        EnergyUtils.log('MAIN_ERROR', f'ä»»åŠ¡æ‰§è¡Œå¤±è´¥: {str(e)}')
        print(f"ä»»åŠ¡æ‰§è¡Œå¤±è´¥: {str(e)}")
        sys.exit(1)


if __name__ == '__main__':
    main()
-e 

--- File: ./energy_rental_bot/controllers/energy_controller.py ---
"""
èƒ½é‡ç§Ÿèµæœºå™¨äººæ§åˆ¶å™¨ç±»
"""

import json
from urllib.parse import quote
from energy_rental_bot.models.energy_models import EnergyAiBishuModel
from energy_rental_bot.utils.energy_utils import EnergyUtils


class TrongasIoController:
    """TrongasIoæ§åˆ¶å™¨ - å¤„ç†ç¬”æ•°èƒ½é‡å›è°ƒé€šçŸ¥"""

    def notice(self, request):
        """trongasç¬”æ•°å›è°ƒé€šçŸ¥"""
        receive_address = request.get('receiveAddress', '')
        residue = request.get('residue', '')

        if receive_address:
            # æŸ¥åœ°å€é€šçŸ¥
            bishu = self.get_energy_ai_bishu_by_wallet(receive_address)
            if bishu and bishu.get('tg_uid') and bishu['tg_uid']:
                # é€šçŸ¥ç”¨æˆ·
                self.notify_user_energy_success(bishu, receive_address, residue)

            # é€šçŸ¥åˆ°ç¾¤
            if bishu.get('tg_notice_obj_send') and bishu['tg_notice_obj_send']:
                self.notify_group_energy_success(bishu, receive_address)

        return {'code': 200, 'msg': 'success'}

    def get_energy_ai_bishu_by_wallet(self, wallet_addr):
        """æ ¹æ®é’±åŒ…åœ°å€è·å–ç¬”æ•°å¥—é¤ä¿¡æ¯"""
        model = EnergyAiBishuModel()
        return model.get_by_wallet_addr(wallet_addr)

    def notify_user_energy_success(self, bishu, receive_address, residue):
        """é€šçŸ¥ç”¨æˆ·èƒ½é‡è´­ä¹°æˆåŠŸ"""
        keyboard = {
            'inline_keyboard': [
                [
                    {'text': 'èƒ½é‡é—ªç§Ÿ', 'url': f'https://t.me/{bishu["bot_username"]}'},
                    {'text': 'ç¬”æ•°å¥—é¤', 'url': f'https://t.me/{bishu["bot_username"]}'},
                    {'text': 'æ™ºèƒ½æ‰˜ç®¡', 'url': f'https://t.me/{bishu["bot_username"]}'}
                ],
                [
                    {'text': 'è”ç³»å®¢æœ', 'url': f'https://t.me/{bishu["bot_admin_username"][1:]}'},
                    {'text': 'TRXé—ªå…‘', 'url': f'https://t.me/{bishu["bot_username"]}'},
                    {'text': 'TRXé¢„æ”¯', 'url': f'https://t.me/{bishu["bot_admin_username"][1:]}'}
                ]
            ]
        }

        encoded_keyboard = json.dumps(keyboard)

        reply_text_uid = (
            "ğŸ–Œ<b>æ–°çš„ç¬”æ•°èƒ½é‡è®¢å•æˆåŠŸ</b> \n"
            "â–â–â–â–â–â–â–â–\n"
            "<b>ä¸‹å•æ¨¡å¼</b>ï¼šç¬”æ•°å¥—é¤\n"
            f"<b>èƒ½é‡æ•°é‡</b>ï¼š{bishu['per_bishu_energy_quantity']} \n"
            f"<b>èƒ½é‡åœ°å€</b>ï¼š{EnergyUtils.format_address(receive_address)}\n\n"
            "<b>èƒ½é‡å·²ç»åˆ°è´¦ï¼è¯·åœ¨æ—¶é—´èŒƒå›´å†…ä½¿ç”¨ï¼</b>\n"
            "å‘é€ /buyenergy ç»§ç»­è´­ä¹°èƒ½é‡ï¼\n\n"
            f"âš ï¸<u>é¢„è®¡å‰©ä½™ï¼š</u>{residue}\n"
            "â–â–â–â–â–â–â–â–"
        )

        send_message_url = (
            f"https://api.telegram.org/bot{bishu['bot_token']}/sendMessage"
            f"?chat_id={bishu['tg_uid']}&text={quote(reply_text_uid)}&parse_mode=HTML&reply_markup={quote(encoded_keyboard)}"
        )

        # å‘é€HTTPè¯·æ±‚
        EnergyUtils.send_http_request(send_message_url)

    def notify_group_energy_success(self, bishu, receive_address):
        """é€šçŸ¥ç¾¤ç»„èƒ½é‡è´­ä¹°æˆåŠŸ"""
        keyboard = {
            'inline_keyboard': [
                [
                    {'text': 'èƒ½é‡é—ªç§Ÿ', 'url': f'https://t.me/{bishu["bot_username"]}'},
                    {'text': 'ç¬”æ•°å¥—é¤', 'url': f'https://t.me/{bishu["bot_username"]}'},
                    {'text': 'æ™ºèƒ½æ‰˜ç®¡', 'url': f'https://t.me/{bishu["bot_username"]}'}
                ],
                [
                    {'text': 'è”ç³»å®¢æœ', 'url': f'https://t.me/{bishu["bot_admin_username"][1:]}'},
                    {'text': 'TRXé—ªå…‘', 'url': f'https://t.me/{bishu["bot_username"]}'},
                    {'text': 'TRXé¢„æ”¯', 'url': f'https://t.me/{bishu["bot_admin_username"][1:]}'}
                ]
            ]
        }

        encoded_keyboard = json.dumps(keyboard)

        reply_text = (
            "ğŸ–Œ<b>æ–°çš„ç¬”æ•°èƒ½é‡è®¢å•æˆåŠŸ</b> \n"
            "â–â–â–â–â–â–â–â–\n"
            "<b>ä¸‹å•æ¨¡å¼</b>ï¼šç¬”æ•°å¥—é¤\n"
            f"<b>èƒ½é‡æ•°é‡</b>ï¼š{bishu['per_bishu_energy_quantity']} \n"
            f"<b>èƒ½é‡åœ°å€</b>ï¼š{EnergyUtils.format_address(receive_address)}\n\n"
            "<b>èƒ½é‡å·²ç»åˆ°è´¦ï¼è¯·åœ¨æ—¶é—´èŒƒå›´å†…ä½¿ç”¨ï¼</b>\n"
            "å‘é€ /buyenergy ç»§ç»­è´­ä¹°èƒ½é‡ï¼\n"
            "â–â–â–â–â–â–â–â–"
        )

        send_list = bishu['tg_notice_obj_send'].split(',')

        for group_id in send_list:
            send_message_url = (
                f"https://api.telegram.org/bot{bishu['bot_token']}/sendMessage"
                f"?chat_id={group_id.strip()}&text={quote(reply_text)}&parse_mode=HTML&reply_markup={quote(encoded_keyboard)}"
            )

            EnergyUtils.send_http_request(send_message_url)
-e 

--- File: ./energy_rental_bot/controllers/__init__.py ---
"""
æ§åˆ¶å™¨åŒ…
"""
-e 

--- File: ./energy_rental_bot/services/energy_services.py ---
"""
èƒ½é‡ç§Ÿèµæœºå™¨äººæœåŠ¡ç±»
"""

import json
import time
from energy_rental_bot.models.energy_models import (
    EnergyPlatformBotModel,
    EnergyWalletTradeListModel
)
from energy_rental_bot.utils.energy_utils import EnergyUtils


class EnergyWalletServices:
    """èƒ½é‡é’±åŒ…æœåŠ¡"""

    def get_list(self, status=0):
        """è·å–èƒ½é‡é’±åŒ…åˆ—è¡¨"""
        model = EnergyPlatformBotModel()
        result = model.get_list(status)
        data = {}

        for item in result:
            if item['status'] == 0 and len(item.get('receive_wallet', '')) == 34:
                data[item['rid']] = item

        return data

    def get_id_list(self, return_type=0):
        """è·å–æ”¶æ¬¾é’±åŒ…IDå’Œåç§°åˆ—è¡¨"""
        data = self.get_list()

        if return_type == 1:
            # è¿”å›é’±åŒ…åœ°å€åˆ—è¡¨
            return {k: v['receive_wallet'] for k, v in data.items()}
        elif return_type == 2:
            # è¿”å›é’±åŒ…ä¿¡æ¯å­—å…¸
            return {v['receive_wallet']: v for k, v in data.items()}
        elif return_type == 3:
            # è¿”å›æ´»è·ƒé’±åŒ…åˆ—è¡¨
            return [v for k, v in data.items() if v['status'] in [0, 2]]
        else:
            # è¿”å›åŸºæœ¬ä¿¡æ¯åˆ—è¡¨
            return [{'rid': v['rid'], 'receive_wallet': v['receive_wallet']} for k, v in data.items()]


class EnergyWalletTradeTrxServices:
    """èƒ½é‡é’±åŒ…TRXäº¤æ˜“æœåŠ¡"""

    def __init__(self):
        self.limit = 50

    def get_list(self, wallet_info, start_timestamp, end_timestamp, page=0):
        """è·å–èƒ½é‡é’±åŒ…æ•°æ® - é€šè¿‡tronscanè·å–"""
        limit = self.limit
        start = page * limit

        url = (
            "https://apilist.tronscanapi.com/api/new/transfer"
            "?sort=-timestamp&count=true&limit={}&start={}&address={}&toAddress={}&tokens=_&start_timestamp={}&end_timestamp={}"
        ).format(limit, start, wallet_info['receive_wallet'], wallet_info['receive_wallet'], start_timestamp, end_timestamp)

        api_key = EnergyUtils.get_random_api_key('tronapikey')
        headers = {"TRON-PRO-API-KEY": api_key}

        response = EnergyUtils.send_http_request(url, headers=headers)
        if response:
            try:
                data = json.loads(response)
                if 'total' in data and data.get('data'):
                    self.handle_wallet_data(data, wallet_info, start_timestamp, end_timestamp, page, limit)
            except json.JSONDecodeError:
                EnergyUtils.log('TRX_TRADE_ERROR', f'è§£æTRXäº¤æ˜“æ•°æ®å¤±è´¥: {response}')

    def handle_wallet_data(self, data, wallet_info, start_timestamp, end_timestamp, page, limit):
        """å¤„ç†æ”¶æ¬¾æ•°æ®"""
        if 'data' in data:
            transactions = data['data']
            total = data.get('total', 0)

            if transactions:
                hash_list = [tx.get('transactionHash') for tx in transactions]
                existing_hashes = self.check_existing_hashes(hash_list)

                current_time = EnergyUtils.now_date()

                for tx in transactions:
                    if (tx.get('transactionHash') not in existing_hashes
                        and tx.get('contractRet') == 'SUCCESS'
                        and EnergyUtils.calculate_amount(tx.get('amount', 0), 6) >= 1
                        and tx.get('tokenInfo', {}).get('tokenId') == '_'
                        and tx.get('tokenInfo', {}).get('tokenAbbr') == 'trx'):

                        self.add_wallet_data(tx, current_time, wallet_info)

                # åˆ†é¡µå¤„ç†
                get_total = (page + 1) * limit
                if total > get_total and len(transactions) == limit:
                    self.get_list(wallet_info, start_timestamp, end_timestamp, page + 1)

    def add_wallet_data(self, tx_data, current_time, wallet_info):
        """æ·»åŠ é’±åŒ…äº¤æ˜“æ•°æ®"""
        tx_record = {
            'tx_hash': tx_data.get('transactionHash'),
            'transferfrom_address': tx_data.get('transferFromAddress'),
            'timestamp': tx_data.get('timestamp'),
            'transferto_address': wallet_info['receive_wallet'],
            'coin_name': 'trx',
            'amount': EnergyUtils.calculate_amount(tx_data.get('amount', 0), 6),
            'get_time': current_time,
            'process_status': 1,
            'process_comments': 'å¾…å¤„ç†',
            'process_time': current_time
        }

        model = EnergyWalletTradeListModel()
        model.insert(tx_record)

    def check_existing_hashes(self, hash_list):
        """æ£€æŸ¥å·²å­˜åœ¨çš„äº¤æ˜“å“ˆå¸Œ"""
        model = EnergyWalletTradeListModel()
        return model.get_by_tx_hash(hash_list)


class EnergyWalletTradeUsdtServices:
    """èƒ½é‡é’±åŒ…USDTäº¤æ˜“æœåŠ¡"""

    def get_list(self, wallet_info, start_timestamp, next_url='0'):
        """è·å–é—ªå…‘é’±åŒ…æ•°æ®"""
        if next_url != '0':
            url = next_url
        else:
            url = (
                "https://api.trongrid.io/v1/accounts/{}/transactions/trc20"
                "?limit=50&only_to=true&min_timestamp={}&contract_address=TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"
            ).format(wallet_info['receive_wallet'], start_timestamp)

        api_key = EnergyUtils.get_random_api_key('gridapikey')
        headers = {"TRON-PRO-API-KEY": api_key}

        response = EnergyUtils.send_http_request(url, headers=headers)
        if response:
            try:
                data = json.loads(response)
                self.handle_wallet_data(data, wallet_info)
            except json.JSONDecodeError:
                EnergyUtils.log('USDT_TRADE_ERROR', f'è§£æUSDTäº¤æ˜“æ•°æ®å¤±è´¥: {response}')

    def handle_wallet_data(self, data, wallet_info):
        """å¤„ç†æ”¶æ¬¾æ•°æ®"""
        if 'data' in data:
            transactions = data['data']

            if transactions:
                hash_list = [tx.get('transaction_id') for tx in transactions]
                existing_hashes = self.check_existing_hashes(hash_list)

                current_time = EnergyUtils.now_date()

                for tx in transactions:
                    if tx.get('transaction_id') not in existing_hashes and tx.get('type') == 'Transfer':
                        self.add_wallet_data(tx, current_time, wallet_info)

                # å¤„ç†ä¸‹ä¸€é¡µ
                if 'meta' in data and 'links' in data['meta'] and 'next' in data['meta']['links']:
                    self.get_list(wallet_info, 0, data['meta']['links']['next'])

    def add_wallet_data(self, tx_data, current_time, wallet_info):
        """æ·»åŠ é’±åŒ…äº¤æ˜“æ•°æ®"""
        tx_record = {
            'tx_hash': tx_data.get('transaction_id'),
            'transferfrom_address': tx_data.get('from'),
            'timestamp': tx_data.get('block_timestamp'),
            'transferto_address': wallet_info['receive_wallet'],
            'coin_name': 'usdt',
            'amount': EnergyUtils.calculate_amount(tx_data.get('value', 0), 6),
            'get_time': current_time,
            'process_status': 1,
            'process_comments': 'å¾…å¤„ç†',
            'process_time': current_time
        }

        model = EnergyWalletTradeListModel()
        model.insert(tx_record)

    def check_existing_hashes(self, hash_list):
        """æ£€æŸ¥å·²å­˜åœ¨çš„äº¤æ˜“å“ˆå¸Œ"""
        model = EnergyWalletTradeListModel()
        return model.get_by_tx_hash(hash_list)
-e 

--- File: ./energy_rental_bot/services/__init__.py ---
"""
æœåŠ¡åŒ…
"""
-e 

